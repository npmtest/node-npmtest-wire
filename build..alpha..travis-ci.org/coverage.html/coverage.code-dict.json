{"/home/travis/build/npmtest/node-npmtest-wire/test.js":"/* istanbul instrument in package npmtest_wire */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-wire/lib.npmtest_wire.js":"/* istanbul instrument in package npmtest_wire */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_wire = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_wire = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-wire/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-wire && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_wire */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_wire\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_wire.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_wire.rollup.js'] =\n            local.assetsDict['/assets.npmtest_wire.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_wire.__dirname + '/lib.npmtest_wire.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/wire.js":"/** @license MIT License (c) copyright 2011-2013 original author or authors */\n\n/**\n * wire\n * Javascript IOC Container\n *\n * wire is part of the cujoJS family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @author Brian Cavalier\n * @author John Hann\n * @version 0.10.11\n */\n(function(rootSpec, define){ 'use strict';\ndefine(function(require) {\n\n\tvar createContext, rootContext, rootOptions;\n\n\twire.version = '0.10.11';\n\n\tcreateContext = require('./lib/context');\n\n\trootOptions = { require: require };\n\n\t/**\n\t * Main Programmtic API.  The top-level wire function that wires contexts\n\t * as direct children of the (possibly implicit) root context.  It ensures\n\t * that the root context has been wired before wiring children.\n\t *\n\t * @public\n\t *\n\t * @param spec {Object|String|Array|Promise} can be any one of the following:\n\t *  1. Object - wiring spec\n\t *  2. String - module id of the wiring spec to load and then wire\n\t *  3. Array - mixed array of Strings and Objects, each of which is either\n\t *   a wiring spec, or the module id of a wiring spec\n\t *  4. Promise - a promise for any of the above\n\t *  @param options {Object} wiring options\n\t *  @param [options.require] {Function} the platform loader function.  Wire will\n\t *   attempt to automatically detect what loader to use (AMD, CommonJS, etc.), but\n\t *   if you want to explicitly provide it, you can do so.  In some cases this can\n\t *   be useful such as providing a local AMD require function so that module ids\n\t *   *within the wiring spec* can be relative.\n\t *  @return {Promise} a promise for the resulting wired context\n\t */\n\tfunction wire(spec, options) {\n\n\t\t// If the root context is not yet wired, wire it first\n\t\tif (!rootContext) {\n\t\t\trootContext = createContext(rootSpec, null, rootOptions);\n\t\t}\n\n\t\t// Use the rootContext to wire all new contexts.\n\t\treturn rootContext.then(function (root) {\n\t\t\treturn root.wire(spec, options);\n\t\t});\n\t}\n\n\t/**\n\t * AMD Loader plugin API\n\t * @param name {String} spec module id, or comma-separated list of module ids\n\t * @param require {Function} loader-provided local require function\n\t * @param done {Function} loader-provided callback to call when wiring\n\t *  is completed. May have and error property that a function to call to\n\t *  inform the AMD loader of an error.\n\t *  See here:\n\t *  https://groups.google.com/forum/?fromgroups#!topic/amd-implement/u0f161drdJA\n\t */\n\twire.load = function amdLoad(name, require, done /*, config */) {\n\t\t// If it's a string, try to split on ',' since it could be a comma-separated\n\t\t// list of spec module ids\n\t\twire(name.split(','), { require: require })\n\t\t\t.then(done, done.error)\n\t\t\t.otherwise(crash);\n\n\t\tfunction crash(e) {\n\t\t\t// Throw uncatchable exception for loaders that don't support\n\t\t\t// AMD error handling.  This will propagate up to the host environment\n\t\t\tsetTimeout(function() { throw e; }, 0);\n\t\t}\n\t};\n\n\t/**\n\t * AMD Builder plugin API\n\t */\n\t// pluginBuilder: './builder/rjs'\n\twire['pluginBuilder'] = './builder/rjs';\n\twire['cramPlugin'] = './builder/cram';\n\n\treturn wire;\n\n});\n})(\n\tthis['wire'] || {},\n\ttypeof define == 'function' && define.amd\n\t\t? define : function(factory) { module.exports = factory(require); }\n);\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/lib/context.js":"/** @license MIT License (c) copyright 2010-2013 original author or authors */\n\n/**\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @author: Brian Cavalier\n * @author: John Hann\n */\n(function(define){ 'use strict';\ndefine(function(require) {\n\n\tvar when, mixin, loaderAdapter, relativeLoader, Container, specUtils;\n\n\twhen = require('when');\n\tmixin = require('./object').mixin;\n\tloaderAdapter = require('./loader/adapter');\n\trelativeLoader = require('./loader/relative');\n\tContainer = require('./Container');\n\tspecUtils = require('./specUtils');\n\n\t/**\n\t * Creates a new context from the supplied specs, with the supplied\n\t * parent context. If specs is an {Array}, it may be a mixed array\n\t * of string module ids, and object literal specs.  All spec module\n\t * ids will be loaded, and then all specs will be merged from\n\t * left-to-right (rightmost wins), and the resulting, merged spec will\n\t * be wired.\n\t * @private\n\t *\n\t * @param {String|Object|String[]|Object[]} specs\n\t * @param {Object} parent context\n\t * @param {Object} [options]\n\t *\n\t * @return {Promise} a promise for the new context\n\t */\n\treturn function createContext(specs, parent, options) {\n\t\t// Do the actual wiring after all specs have been loaded\n\n\t\tif(!options) { options = {}; }\n\t\tif(!parent)  { parent  = {}; }\n\n\t\toptions.createContext = createContext;\n\n\t\tvar specLoader = createSpecLoader(parent.moduleLoader, options.require);\n\n\t\treturn when(specs, function(specs) {\n\t\t\toptions.moduleLoader =\n\t\t\t\tcreateContextLoader(specLoader, findBaseId(specs));\n\n\t\t\treturn specUtils.mergeSpecs(specLoader, specs).then(function(spec) {\n\n\t\t\t\tvar container = new Container(parent, options);\n\n\t\t\t\t// Expose only the component instances and controlled API\n\t\t\t\treturn container.init(spec).then(function(context) {\n\t\t\t\t\treturn context.instances;\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t};\n\n\tfunction createContextLoader(parentLoader, baseId) {\n\t\treturn baseId ? relativeLoader(parentLoader, baseId) : parentLoader;\n\t}\n\n\t/**\n\t * Create a module loader\n\t * @param {function} [platformLoader] platform require function with which\n\t *  to configure the module loader\n\t * @param {function} [parentLoader] existing module loader from which\n\t *  the new module loader will inherit, if provided.\n\t * @return {Object} module loader with load() and merge() methods\n\t */\n\tfunction createSpecLoader(parentLoader, platformLoader) {\n\t\tvar loadModule = typeof platformLoader == 'function'\n\t\t\t? loaderAdapter(platformLoader)\n\t\t\t: parentLoader || loaderAdapter(require);\n\n\t\treturn loadModule;\n\t}\n\n\tfunction findBaseId(specs) {\n\t\tvar firstId;\n\n\t\tif(typeof specs === 'string') {\n\t\t\treturn specs;\n\t\t}\n\n\t\tif(!Array.isArray(specs)) {\n\t\t\treturn;\n\t\t}\n\n\t\tspecs.some(function(spec) {\n\t\t\tif(typeof spec === 'string') {\n\t\t\t\tfirstId = spec;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\treturn firstId;\n\t}\n});\n}(typeof define === 'function' ? define : function(factory) { module.exports = factory(require); }));\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/lib/object.js":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\n\n(function(define){ 'use strict';\ndefine(function() {\n\n\tvar hasOwn;\n\n\thasOwn = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);\n\n\treturn {\n\t\thasOwn: hasOwn,\n\t\tisObject: isObject,\n\t\tinherit: inherit,\n\t\tmixin: mixin,\n\t\textend: extend\n\t};\n\n\tfunction isObject(it) {\n\t\t// In IE7 tos.call(null) is '[object Object]'\n\t\t// so we need to check to see if 'it' is\n\t\t// even set\n\t\treturn it && Object.prototype.toString.call(it) == '[object Object]';\n\t}\n\n\tfunction inherit(parent) {\n\t\treturn parent ? Object.create(parent) : {};\n\t}\n\n\t/**\n\t * Brute force copy own properties from -> to. Effectively an\n\t * ES6 Object.assign polyfill, usable with Array.prototype.reduce.\n\t * @param {object} to\n\t * @param {object} from\n\t * @returns {object} to\n\t */\n\tfunction mixin(to, from) {\n\t\tif(!from) {\n\t\t\treturn to;\n\t\t}\n\n\t\treturn Object.keys(from).reduce(function(to, key) {\n\t\t\tto[key] = from[key];\n\t\t\treturn to;\n\t\t}, to);\n\t}\n\n\t/**\n\t * Beget a new object from base and then mixin own properties from\n\t * extensions.  Equivalent to mixin(inherit(base), extensions)\n\t * @param {object} base\n\t * @param {object} extensions\n\t * @returns {object}\n\t */\n\tfunction extend(base, extensions) {\n\t\treturn mixin(inherit(base), extensions);\n\t}\n\n});\n})(typeof define == 'function'\n\t// AMD\n\t? define\n\t// CommonJS\n\t: function(factory) { module.exports = factory(); }\n);","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/lib/loader/adapter.js":"/** @license MIT License (c) copyright 2010-2013 original author or authors */\n\n/**\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @author: Brian Cavalier\n * @author: John Hann\n */\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar when = require('when');\n\n\t// Sniff for the platform's loader\n\treturn typeof exports == 'object'\n\t\t? function(require) {\n\t\t\treturn function(moduleId) {\n\t\t\t\ttry {\n\t\t\t\t\treturn when.resolve(require(moduleId));\n\t\t\t\t} catch(e) {\n\t\t\t\t\treturn when.reject(e);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\t: function (require) {\n\t\t\treturn function(moduleId) {\n\t\t\t\tvar deferred = when.defer();\n\t\t\t\trequire([moduleId], deferred.resolve, deferred.reject);\n\t\t\t\treturn deferred.promise;\n\t\t\t};\n\t\t};\n\n});\n}(typeof define === 'function' ? define : function(factory) { module.exports = factory(require); }));\n\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/lib/loader/relative.js":"/** @license MIT License (c) copyright 2010-2013 original author or authors */\n\n/**\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @author: Brian Cavalier\n * @author: John Hann\n */\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar mid = require('./moduleId');\n\n\treturn function relativeLoader(loader, referenceId) {\n\t\treferenceId = mid.base(referenceId);\n\t\treturn function(moduleId) {\n\t\t\treturn loader(mid.resolve(referenceId, moduleId));\n\t\t};\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/lib/loader/moduleId.js":"/** @license MIT License (c) copyright 2010-2013 original author or authors */\n\n/**\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @author: Brian Cavalier\n * @author: John Hann\n */\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn {\n\t\tbase: base,\n\t\tresolve: resolve\n\t};\n\n\t/**\n\t * Given a moduleId, returns the \"basename\".  For example:\n\t * base('foo/bar/baz') -> 'foo/bar'\n\t * base('foo') -> 'foo'\n\t * @param id\n\t * @returns {*}\n\t */\n\tfunction base(id) {\n\t\tif(!id) {\n\t\t\treturn '';\n\t\t}\n\n\t\tvar split = id.lastIndexOf('/');\n\t\treturn split >= 0 ? id.slice(0, split) : id;\n\t}\n\n\t/**\n\t * Resolve id against base (which is also an id), such that the\n\t * returned resolved id contains no leading '.' or '..'\n\t * components.  Id may be relative or absolute, and may also\n\t * be an AMD plugin plus resource id, in which case both the\n\t * plugin id and the resource id may be relative or absolute.\n\t * @param {string} base module id against which id will be resolved\n\t * @param {string} id module id to resolve, may be an\n\t *  AMD plugin+resource id.\n\t * @returns {string} resolved id with no leading '.' or '..'\n\t *  components.  If the input id was an AMD plugin+resource id,\n\t *  both the plugin id and the resource id will be resolved in\n\t *  the returned id (thus neither will have leading '.' or '..'\n\t *  components)\n\t */\n\tfunction resolve(base, id) {\n\t\tif(typeof id != 'string') {\n\t\t\treturn base;\n\t\t}\n\n\t\treturn id.split('!').map(function(part) {\n\t\t\treturn resolveId(base, part.trim());\n\t\t}).join('!');\n\t}\n\n\tfunction resolveId(base, id) {\n\t\tvar up, prefix;\n\n\t\tif(id === '' || id === '.' || id === './') {\n\t\t\treturn base;\n\t\t}\n\n\t\tif(id[0] != '.') {\n\t\t\treturn id;\n\t\t}\n\n\t\tprefix = base;\n\n\t\tif(id == '..' || id == '../') {\n\t\t\tup = 1;\n\t\t\tid = '';\n\t\t} else {\n\t\t\tup = 0;\n\t\t\tid = id.replace(/^(\\.\\.?\\/)+/, function(s) {\n\t\t\t\ts.replace(/\\.\\./g, function(s) {\n\t\t\t\t\tup++;\n\t\t\t\t\treturn s;\n\t\t\t\t});\n\t\t\t\treturn '';\n\t\t\t});\n\n\t\t\tif(id == '..') {\n\t\t\t\tup++;\n\t\t\t\tid = '';\n\t\t\t} else if(id == '.') {\n\t\t\t\tid = '';\n\t\t\t}\n\t\t}\n\n\t\tif(up > 0) {\n\t\t\tprefix = prefix.split('/');\n\t\t\tup = Math.max(0, prefix.length - up);\n\t\t\tprefix = prefix.slice(0, up).join('/');\n\t\t}\n\n\t\tif(id.length && id[0] !== '/' && prefix[prefix.length-1] !== '/') {\n\t\t\tprefix += '/';\n\t\t}\n\n\t\tif(prefix[0] == '/') {\n\t\t\tprefix = prefix.slice(1);\n\t\t}\n\n\t\treturn prefix + id;\n\t}\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/lib/Container.js":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\n\n(function(define){ 'use strict';\ndefine(function(require) {\n\n\tvar when, advice, object, WireContext, Scope,\n\t\tPluginRegistry, defaultPlugins,\n\t\tDirectedGraph, trackInflightRefs, slice, scopeProto, undef;\n\n\twhen = require('when');\n\tadvice = require('./advice');\n\tobject = require('./object');\n\tWireContext = require('./WireContext');\n\tScope = require('./scope');\n\tPluginRegistry = require('./plugin/registry');\n\tdefaultPlugins = require('./plugin/defaultPlugins');\n\tDirectedGraph = require('./graph/DirectedGraph');\n\ttrackInflightRefs = require('./graph/trackInflightRefs');\n\tslice = Array.prototype.slice;\n\n\tscopeProto = Scope.prototype;\n\n\tfunction Container() {\n\t\tScope.apply(this, arguments);\n\t}\n\n\t/**\n\t * Container inherits from Scope, adding plugin support and\n\t * context level events.\n\t */\n\tContainer.prototype = object.extend(scopeProto, {\n\t\t_inheritInstances: function(parent) {\n\t\t\tvar publicApi = {\n\t\t\t\twire: this._createChildContext.bind(this),\n\t\t\t\tdestroy: this.destroy.bind(this),\n\t\t\t\tresolve: this._resolveRef.bind(this)\n\t\t\t};\n\n\t\t\treturn WireContext.inherit(parent.instances, publicApi);\n\t\t},\n\n\t\t_init: advice.after(\n\t\t\tscopeProto._init,\n\t\t\tfunction() {\n\t\t\t\tthis.plugins = new PluginRegistry();\n\t\t\t\treturn this._installDefaultPlugins();\n\t\t\t}\n\t\t),\n\n\t\t_startup: advice.after(\n\t\t\tscopeProto._startup,\n\t\t\tfunction(started) {\n\t\t\t\tvar self = this;\n\t\t\t\treturn when.resolve(started).otherwise(function(e) {\n\t\t\t\t\treturn self._contextEvent('error', e).yield(started);\n\t\t\t\t});\n\t\t\t}\n\t\t),\n\n\t\t_installDefaultPlugins: function() {\n\t\t\treturn this._installPlugins(defaultPlugins);\n\t\t},\n\n\t\t_installPlugins: function(plugins) {\n\t\t\tif(!plugins) {\n\t\t\t\treturn when.resolve();\n\t\t\t}\n\n\t\t\tvar self, registry, installed;\n\n\t\t\tself = this;\n\t\t\tregistry = this.plugins;\n\n\t\t\tif(Array.isArray(plugins)) {\n\t\t\t\tinstalled = plugins.map(function(plugin) {\n\t\t\t\t\treturn installPlugin(plugin);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tinstalled = Object.keys(plugins).map(function(namespace) {\n\t\t\t\t\treturn installPlugin(plugins[namespace], namespace);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn when.all(installed);\n\n\t\t\tfunction installPlugin(pluginSpec, namespace) {\n\t\t\t\tvar module, t;\n\n\t\t\t\tt = typeof pluginSpec;\n\t\t\t\tif(t == 'string') {\n\t\t\t\t\tmodule = pluginSpec;\n\t\t\t\t\tpluginSpec = {};\n\t\t\t\t} else if(typeof pluginSpec.module == 'string') {\n\t\t\t\t\tmodule = pluginSpec.module;\n\t\t\t\t} else {\n\t\t\t\t\tmodule = pluginSpec;\n\t\t\t\t}\n\n\t\t\t\treturn self.getModule(module).then(function(plugin) {\n\t\t\t\t\treturn registry.scanModule(plugin, pluginSpec, namespace);\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\t_createResolver: advice.after(\n\t\t\tscopeProto._createResolver,\n\t\t\tfunction(resolver) {\n\t\t\t\treturn trackInflightRefs(\n\t\t\t\t\tnew DirectedGraph(), resolver, this.refCycleTimeout);\n\t\t\t}\n\t\t),\n\n\t\t_contextEvent: function (type, data) {\n\t\t\tvar api, listeners;\n\n\t\t\tif(!this.contextEventApi) {\n\t\t\t\tthis.contextEventApi = this._pluginApi.contextualize(this.path);\n\t\t\t}\n\n\t\t\tapi = this.contextEventApi;\n\t\t\tlisteners = this.plugins.contextListeners;\n\n\t\t\treturn when.reduce(listeners, function(undef, listener) {\n\t\t\t\tvar d;\n\n\t\t\t\tif(listener[type]) {\n\t\t\t\t\td = when.defer();\n\t\t\t\t\tlistener[type](d.resolver, api, data);\n\t\t\t\t\treturn d.promise;\n\t\t\t\t}\n\n\t\t\t\treturn undef;\n\t\t\t}, undef);\n\t\t},\n\n\t\t_createComponents: advice.beforeAsync(\n\t\t\tscopeProto._createComponents,\n\t\t\tfunction(parsed) {\n\t\t\t\tvar self = this;\n\t\t\t\treturn this._installPlugins(parsed.plugins)\n\t\t\t\t\t.then(function() {\n\t\t\t\t\t\treturn self._contextEvent('initialize');\n\t\t\t\t\t});\n\t\t\t}\n\t\t),\n\n\t\t_awaitInstances: advice.afterAsync(\n\t\t\tscopeProto._awaitInstances,\n\t\t\tfunction() {\n\t\t\t\treturn this._contextEvent('ready');\n\t\t\t}\n\t\t),\n\n\t\t_destroyComponents: advice.beforeAsync(\n\t\t\tscopeProto._destroyComponents,\n\t\t\tfunction() {\n\t\t\t\treturn this._contextEvent('shutdown');\n\t\t\t}\n\t\t),\n\n\t\t_releaseResources: advice.beforeAsync(\n\t\t\tscopeProto._releaseResources,\n\t\t\tfunction() {\n\t\t\t\treturn this._contextEvent('destroy');\n\t\t\t}\n\t\t)\n\t});\n\n\treturn Container;\n\n});\n}(typeof define === 'function' ? define : function(factory) { module.exports = factory(require); }));\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/lib/advice.js":"/** @license MIT License (c) copyright 2010-2013 original author or authors */\n\n/**\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @author: Brian Cavalier\n * @author: John Hann\n */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar when;\n\n\twhen = require('when');\n\n\t// Very simple advice functions for internal wire use only.\n\t// This is NOT a replacement for meld.  These advices stack\n\t// differently and will not be as efficient.\n\treturn {\n\t\tbefore: before,\n\t\tafter: after,\n\t\tbeforeAsync: beforeAsync,\n\t\tafterAsync: afterAsync\n\t};\n\n\t/**\n\t * Execute advice before f, passing same arguments to both, and\n\t * discarding advice's return value.\n\t * @param {function} f function to advise\n\t * @param {function} advice function to execute before f\n\t * @returns {function} advised function\n\t */\n\tfunction before(f, advice) {\n\t\treturn function() {\n\t\t\tadvice.apply(this, arguments);\n\t\t\treturn f.apply(this, arguments);\n\t\t};\n\t}\n\n\t/**\n\t * Execute advice after f, passing f's return value to advice\n\t * @param {function} f function to advise\n\t * @param {function} advice function to execute after f\n\t * @returns {function} advised function\n\t */\n\tfunction after(f, advice) {\n\t\treturn function() {\n\t\t\treturn advice.call(this, f.apply(this, arguments));\n\t\t};\n\t}\n\n\t/**\n\t * Execute f after a promise returned by advice fulfills. The same args\n\t * will be passed to both advice and f.\n\t * @param {function} f function to advise\n\t * @param {function} advice function to execute before f\n\t * @returns {function} advised function which always returns a promise\n\t */\n\tfunction beforeAsync(f, advice) {\n\t\treturn function() {\n\t\t\tvar self, args;\n\n\t\t\tself = this;\n\t\t\targs = arguments;\n\n\t\t\treturn when(args, function() {\n\t\t\t\treturn advice.apply(self, args);\n\t\t\t}).then(function() {\n\t\t\t\treturn f.apply(self, args);\n\t\t\t});\n\t\t};\n\t}\n\n\t/**\n\t * Execute advice after a promise returned by f fulfills. The same args\n\t * will be passed to both advice and f.\n\t * @param {function} f function to advise\n\t * @param {function} advice function to execute after f\n\t * @returns {function} advised function which always returns a promise\n\t */\n\tfunction afterAsync(f, advice) {\n\t\treturn function() {\n\t\t\tvar self = this;\n\n\t\t\treturn when(arguments, function(args) {\n\t\t\t\treturn f.apply(self, args);\n\t\t\t}).then(function(result) {\n\t\t\t\treturn advice.call(self, result);\n\t\t\t});\n\t\t};\n\t}\n\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/lib/WireContext.js":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\n\n(function(define){ 'use strict';\n\tdefine(function(require) {\n\n\t\tvar object, undef;\n\n\t\tobject = require('./object');\n\n\t\tfunction WireContext() {}\n\n\t\tWireContext.inherit = function(parent, api) {\n\t\t\tvar contextApi, context;\n\n\t\t\tcontextApi = object.inherit(parent);\n\t\t\tobject.mixin(contextApi, api);\n\n\t\t\tWireContext.prototype = contextApi;\n\n\t\t\tcontext = new WireContext();\n\t\t\tWireContext.prototype = undef;\n\n\t\t\treturn context;\n\t\t};\n\n\t\treturn WireContext;\n\n\t});\n}(typeof define === 'function' ? define : function(factory) { module.exports = factory(require); }));\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/lib/scope.js":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @author brian@hovercraftstudios.com\n */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar when, defer, sequence, array, object, loader, Map,\n\t\tComponentFactory, Lifecycle, Resolver, WireProxy, PluginRegistry,\n\t\tundef, specUtils, DirectedGraph, cyclesTracker;\n\n\twhen = require('when');\n\tsequence = require('when/sequence');\n\tarray = require('./array');\n\tobject = require('./object');\n\tMap = require('./Map');\n\tloader = require('./loader/adapter');\n\tComponentFactory = require('./ComponentFactory');\n\tLifecycle = require('./lifecycle');\n\tResolver = require('./resolver');\n\tWireProxy = require('./WireProxy');\n\tPluginRegistry = require('./plugin/registry');\n\tspecUtils = require('./specUtils');\n\tDirectedGraph = require('./graph/DirectedGraph');\n\tcyclesTracker = require('./graph/cyclesTracker');\n\t\n\tdefer = when.defer;\n\n\tfunction Scope(parent, options) {\n\t\tthis.parent = parent||{};\n\t\tobject.mixin(this, options);\n\t}\n\n\tScope.prototype = {\n\n\t\tinit: function(spec) {\n\n\t\t\tthis._inherit(this.parent);\n\t\t\tthis._init();\n\t\t\tthis._configure();\n\n\t\t\treturn this._startup(spec).yield(this);\n\t\t},\n\n\t\t_inherit: function(parent) {\n\n\t\t\tthis._instanceToProxy = new Map();\n\n\t\t\tthis.instances = this._inheritInstances(parent);\n\t\t\tthis.components = object.inherit(parent.components);\n\n\t\t\tthis.path = this._createPath(this.name, parent.path);\n\n\t\t\tthis.plugins = parent.plugins;\n\n\t\t\tthis.initializers = array.delegate(this.initializers);\n\t\t\tthis.destroyers = array.delegate(this.destroyers);\n\t\t\tthis.postDestroy = array.delegate(this.postDestroy);\n\n\t\t\tif(!this.moduleLoader) {\n\t\t\t\tthis.moduleLoader = parent.moduleLoader;\n\t\t\t}\n\t\t},\n\n\t\t_inheritInstances: function(parent) {\n\t\t\treturn object.inherit(parent.instances);\n\t\t},\n\n\t\t_addDependent: function(dependant, tasks) {\n\t\t\treturn dependant.then(\n\t\t\t\tfunction(dependant) {\n\t\t\t\t\ttasks.push(function() {\n\t\t\t\t\t\treturn dependant.destroy();\n\t\t\t\t\t});\n\t\t\t\t\treturn dependant;\n\t\t\t\t}\n\t\t\t);\n\n\t\t},\n\n\t\t_createNestedScope: function(spec) {\n\t\t\tvar options = { createContext: this.createContext };\n\t\t\treturn this._addDependent(\n\t\t\t\tnew Scope(this, options).init(spec), this.postDestroy);\n\t\t},\n\n\t\t_createChildContext: function(spec, options) {\n\t\t\t// Create child and arrange for it to be destroyed just before\n\t\t\t// this scope is destroyed\n\t\t\treturn this._addDependent(\n\t\t\t\tthis.createContext(spec, this, options), this.destroyers);\n\t\t},\n\n\t\t_init: function() {\n\t\t\tthis._pluginApi = this._initPluginApi();\n\t\t},\n\n\t\t_initPluginApi: function() {\n\t\t\t// Plugin API\n\t\t\t// wire() API that is passed to plugins.\n\t\t\tvar self, pluginApi;\n\n\t\t\tself = this;\n\t\t\tpluginApi = {};\n\n\t\t\tpluginApi.contextualize = function(name) {\n\t\t\t\tfunction contextualApi(spec, id) {\n\t\t\t\t\treturn self._resolveInstance(self._createComponentDef(id, spec));\n\t\t\t\t}\n\n\t\t\t\tcontextualApi.createChild = self._createChildContext.bind(self);\n\t\t\t\tcontextualApi.loadModule = self.getModule.bind(self);\n\t\t\t\tcontextualApi.resolver = self.resolver;\n\t\t\t\tcontextualApi.addComponent = addComponent;\n\t\t\t\tcontextualApi.addInstance = addInstance;\n\n\t\t\t\tcontextualApi.resolveRef = function(ref) {\n\t\t\t\t\tvar onBehalfOf = arguments.length > 1 ? arguments[2] : name;\n\t\t\t\t\treturn self._resolveRef(ref, onBehalfOf);\n\t\t\t\t};\n\n\t\t\t\tcontextualApi.getProxy = function(nameOrComponent) {\n\t\t\t\t\tvar onBehalfOf = arguments.length > 1 ? arguments[2] : name;\n\t\t\t\t\treturn self.getProxy(nameOrComponent, onBehalfOf);\n\t\t\t\t};\n\n\t\t\t\treturn contextualApi;\n\t\t\t};\n\n\t\t\treturn pluginApi;\n\n\t\t\tfunction addComponent(component, id) {\n\t\t\t\tvar def, instance;\n\n\t\t\t\tdef = self._createComponentDef(id);\n\t\t\t\tinstance = self.componentFactory.processComponent(def, component);\n\n\t\t\t\treturn self._makeResolvable(def, instance);\n\t\t\t}\n\n\t\t\tfunction addInstance(instance, id) {\n\t\t\t\tself._makeResolvable(self._createComponentDef(id), instance);\n\t\t\t\treturn when.resolve(instance);\n\t\t\t}\n\t\t},\n\n\t\t_configure: function() {\n\t\t\tvar plugins, pluginApi;\n\n\t\t\tplugins = this.plugins;\n\t\t\tpluginApi = this._pluginApi;\n\n\t\t\tthis.resolver = this._createResolver(plugins, pluginApi);\n\t\t\tthis.componentFactory = this._createComponentFactory(plugins, pluginApi);\n\n\t\t\tthis._destroy = function() {\n\t\t\t\tthis._destroy = noop;\n\n\t\t\t\treturn this._executeDestroyers()\n\t\t\t\t\t.then(this._destroyComponents.bind(this))\n\t\t\t\t\t.then(this._releaseResources.bind(this))\n\t\t\t\t\t.then(this._executePostDestroy.bind(this));\n\t\t\t};\n\t\t},\n\n\t\t_startup: function(spec) {\n\t\t\tvar self = this;\n\n\t\t\treturn this._executeInitializers().then(function() {\n\t\t\t\treturn self._parseSpec(spec).then(function(parsed){\n\t\t\t\t\treturn self._createComponents(parsed).then(function() {\n\t\t\t\t\t\treturn self._awaitInstances(parsed);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\n\t\tdestroy: function() {\n\t\t\treturn this._destroy();\n\t\t},\n\n\t\t_destroy: noop,\n\n\t\t_destroyComponents: function() {\n\t\t\tvar instances = this.instances;\n\n\t\t\treturn this.componentFactory.destroy().then(function() {\n\t\t\t\tfor (var p in instances) {\n\t\t\t\t\tdelete instances[p];\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t_releaseResources: function() {\n\t\t\t// Free Objects\n\t\t\tthis.instances = this.components = this.parent\n\t\t\t\t= this.resolver = this.componentFactory\n\t\t\t\t= this._instanceToProxy = this._pluginApi = this.plugins\n\t\t\t\t= undef;\n\t\t},\n\n\t\tgetModule: function(moduleId) {\n\t\t\treturn typeof moduleId == 'string'\n\t\t\t\t? this.moduleLoader(moduleId)\n\t\t\t\t: when.resolve(moduleId);\n\t\t},\n\n\t\tgetProxy: function(nameOrInstance, onBehalfOf) {\n\t\t\tvar self = this;\n\n\t\t\tif(typeof nameOrInstance === 'string') {\n\t\t\t\treturn this._resolveRefName(nameOrInstance, {}, onBehalfOf)\n\t\t\t\t\t.then(function (instance) {\n\t\t\t\t\t\treturn self._getProxyForInstance(instance);\n\t\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn self._getProxyForInstance(nameOrInstance);\n\t\t\t}\n\t\t},\n\n\t\t_getProxyForInstance: function(instance) {\n\t\t\tvar componentFactory = this.componentFactory;\n\n\t\t\treturn getProxyRecursive(this, instance).otherwise(function() {\n\t\t\t\t// Last ditch, create a new proxy\n\t\t\t\treturn componentFactory.createProxy(instance);\n\t\t\t});\n\t\t},\n\n\t\t_createResolver: function(plugins, pluginApi) {\n\t\t\treturn new Resolver(plugins.resolvers, pluginApi);\n\t\t},\n\n\t\t_createComponentFactory: function(plugins, pluginApi) {\n\t\t\tvar self, factory, init, lifecycle;\n\n\t\t\tself = this;\n\n\t\t\tlifecycle = new Lifecycle(plugins, pluginApi);\n\t\t\tfactory = new ComponentFactory(lifecycle, plugins, pluginApi);\n\n\t\t\tinit = factory.initInstance;\n\t\t\tfactory.initInstance = function() {\n\t\t\t\treturn when(init.apply(factory, arguments), function(proxy) {\n\t\t\t\t\treturn self._makeResolvable(proxy.metadata, proxy);\n\t\t\t\t});\n\t\t\t};\n\n\t\t\treturn factory;\n\t\t},\n\n\t\t_executeInitializers: function() {\n\t\t\treturn sequence(this.initializers, this);\n\t\t},\n\n\t\t_executeDestroyers: function() {\n\t\t\treturn sequence(this.destroyers, this);\n\t\t},\n\n\t\t_executePostDestroy: function() {\n\t\t\treturn sequence(this.postDestroy, this);\n\t\t},\n\n\t\t_parseSpec: function(spec) {\n\t\t\tvar self = this;\n\n\t\t\t// instantiate the imports graph\n\t\t\tvar importsGraph = new DirectedGraph();\n\n\t\t\treturn processImports(self, spec, importsGraph).then(function(specImports){\n\t\t\t\t// modules of importing spec overrides modules of imported spec.\n\t\t\t\treturn processSpec(self, object.mixin(specImports, spec));\n\t\t\t});\n\t\t},\n\n\t\t_createComponentDef: function(id, spec, initialized, ready) {\n\t\t\treturn {\n\t\t\t\tid: id,\n\t\t\t\tspec: spec,\n\t\t\t\tpath: this._createPath(id, this.path),\n\t\t\t\tinitialized: initialized,\n\t\t\t\tready: ready\n\t\t\t};\n\t\t},\n\n\t\t_createComponents: function(parsed) {\n\t\t\t// Process/create each item in scope and resolve its\n\t\t\t// promise when completed.\n\t\t\tvar self, components;\n\n\t\t\tself = this;\n\t\t\tcomponents = parsed.components;\n\t\t\treturn when.map(Object.keys(components), function(name) {\n\t\t\t\treturn self._createScopeItem(components[name]);\n\t\t\t});\n\t\t},\n\n\t\t_awaitInstances: function(parsed) {\n\t\t\tvar ready = parsed.ready;\n\t\t\treturn when.map(Object.keys(ready), function(id) {\n\t\t\t\treturn ready[id];\n\t\t\t});\n\t\t},\n\n\t\t_createScopeItem: function(component) {\n\t\t\t// NOTE: Order is important here.\n\t\t\t// The object & local property assignment MUST happen before\n\t\t\t// the chain resolves so that the concrete item is in place.\n\t\t\t// Otherwise, the whole scope can be marked as resolved before\n\t\t\t// the final item has been resolved.\n\t\t\tvar self, item;\n\n\t\t\tself = this;\n\t\t\titem = this._resolveItem(component).then(function (resolved) {\n\t\t\t\tself._makeResolvable(component, resolved);\n\t\t\t\treturn WireProxy.getTarget(resolved);\n\t\t\t});\n\n\t\t\tcomponent.ready.resolve(item);\n\t\t\treturn item;\n\t\t},\n\n\t\t_makeResolvable: function(component, instance) {\n\t\t\tvar id, inst;\n\n\t\t\tid = component.id;\n\t\t\tif(id != null) {\n\t\t\t\tinst = WireProxy.getTarget(instance);\n\t\t\t\tthis.instances[id] = inst;\n\t\t\t\tif(component.proxy) {\n\t\t\t\t\tthis._instanceToProxy.set(inst, component.proxy);\n\t\t\t\t}\n\t\t\t\tif(component.initialized) {\n\t\t\t\t\tcomponent.initialized.resolve(inst);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn instance;\n\t\t},\n\n\t\t_resolveInstance: function(component) {\n\t\t\treturn this._resolveItem(component).then(WireProxy.getTarget);\n\t\t},\n\n\t\t_resolveItem: function(component) {\n\t\t\tvar item, spec;\n\n\t\t\tspec = component.spec;\n\n\t\t\tif (this.resolver.isRef(spec)) {\n\t\t\t\t// Reference\n\t\t\t\titem = this._resolveRef(spec, component.id);\n\t\t\t} else {\n\t\t\t\t// Component\n\t\t\t\titem = this._createItem(component);\n\t\t\t}\n\n\t\t\treturn item;\n\t\t},\n\n\t\t_createItem: function(component) {\n\t\t\tvar created, spec;\n\n\t\t\tspec = component.spec;\n\n\t\t\tif (Array.isArray(spec)) {\n\t\t\t\t// Array\n\t\t\t\tcreated = this._createArray(component);\n\n\t\t\t} else if (object.isObject(spec)) {\n\t\t\t\t// component spec, create the component\n\t\t\t\tcreated = this._createComponent(component);\n\n\t\t\t} else {\n\t\t\t\t// Plain value\n\t\t\t\tcreated = when.resolve(spec);\n\t\t\t}\n\n\t\t\treturn created;\n\t\t},\n\n\t\t_createArray: function(component) {\n\t\t\tvar self, id, i;\n\n\t\t\tself = this;\n\t\t\tid = component.id;\n\t\t\ti = 0;\n\n\t\t\t// Minor optimization, if it's an empty array spec, just return an empty array.\n\t\t\treturn when.map(component.spec, function(item) {\n\t\t\t\tvar componentDef = self._createComponentDef(id + '[' + (i++) + ']', item);\n\t\t\t\treturn self._resolveInstance(componentDef);\n\t\t\t});\n\t\t},\n\n\t\t_createComponent: function(component) {\n\t\t\tvar self = this;\n\n\t\t\treturn this.componentFactory.create(component)\n\t\t\t\t.otherwise(function (reason) {\n\t\t\t\t\tif(reason !== component) {\n\t\t\t\t\t\tthrow reason;\n\t\t\t\t\t}\n\n\t\t\t\t\t// No factory found, treat object spec as a nested scope\n\t\t\t\t\treturn self._createNestedScope(component.spec)\n\t\t\t\t\t\t.then(function (childScope) {\n\t\t\t\t\t\t\t// TODO: find a lighter weight solution\n\t\t\t\t\t\t\t// We're paying the cost of creating a complete scope,\n\t\t\t\t\t\t\t// then discarding everything except the instance map.\n\t\t\t\t\t\t\treturn object.mixin({}, childScope.instances);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t},\n\n\t\t_resolveRef: function(ref, onBehalfOf) {\n\t\t\tvar scope;\n\n\t\t\tref = this.resolver.parse(ref);\n\t\t\tscope = onBehalfOf == ref.name && this.parent.instances ? this.parent : this;\n\n\t\t\treturn this._doResolveRef(ref, scope.instances, onBehalfOf);\n\t\t},\n\n\t\t_resolveRefName: function(refName, options, onBehalfOf) {\n\t\t\tvar ref = this.resolver.create(refName, options);\n\n\t\t\treturn this._doResolveRef(ref, this.instances, onBehalfOf);\n\t\t},\n\n\t\t_doResolveRef: function(ref, scope, onBehalfOf) {\n\t\t\treturn ref.resolve(function (name) {\n\t\t\t\treturn resolveDeepName(name, scope);\n\t\t\t}, onBehalfOf);\n\t\t},\n\n\t\t_createPath: function(name, basePath) {\n\t\t\tvar path = basePath || this.path;\n\t\t\treturn (path && name) ? (path + '.' + name) : name;\n\t\t}\n\t};\n\n\treturn Scope;\n\n\tfunction resolveDeepName(name, scope) {\n\t\tvar parts = name.split('.');\n\n\t\treturn when.reduce(parts, function(scope, segment) {\n\t\t\treturn segment in scope\n\t\t\t\t? scope[segment]\n\t\t\t\t: when.reject(new Error('Cannot resolve ref: ' + name));\n\t\t}, scope);\n\t}\n\n\tfunction getProxyRecursive(scope, instance) {\n\t\tvar proxy;\n\n\t\tif(scope._instanceToProxy) {\n\t\t\tproxy = scope._instanceToProxy.get(instance);\n\t\t}\n\n\t\tif(!proxy) {\n\t\t\tif(scope.parent) {\n\t\t\t\treturn getProxyRecursive(scope.parent, instance);\n\t\t\t} else {\n\t\t\t\treturn when.reject(new Error('No proxy found'));\n\t\t\t}\n\t\t}\n\n\t\treturn when.resolve(proxy);\n\t}\n\n\tfunction noop() {}\n\n\tfunction processImports(scope, spec, importsGraph, importingModuleId) {\n\t\tif(!spec || !spec.$imports) {\n\t\t\treturn when({});\n\t\t}\n\n\t\tif(typeof spec.$imports === 'string') {\n\t\t\tspec.$imports = [spec.$imports];\n\t\t}\n\n\t\timportingModuleId = importingModuleId || (typeof spec === 'string' ? spec : undefined);\n\n\t\treturn when.reduce(spec.$imports, function(currentSpecImports, importedModuleId){\n\t\t\t// make sure that there is no cycles\n\t\t\tcyclesTracker.ensureNoCycles(importsGraph, importedModuleId, importingModuleId);\n\n\t\t\t// go ahead with the import\n\t\t\treturn when(scope.getModule(importedModuleId), function(importedSpec){\n\t\t\t\treturn processImports(scope, importedSpec, importsGraph, importedModuleId).then(function(importedSpecImports){\n\t\t\t\t\t// modules of importing spec overrides modules of imported specs.\n\t\t\t\t\tvar importedSpecAndItsImports = object.mixin(importedSpecImports, importedSpec);\n\n\t\t\t\t\t// modules in the right overrides modules in the left\n\t\t\t\t\tcurrentSpecImports = object.mixin(currentSpecImports, importedSpecAndItsImports);\n\n\t\t\t\t\treturn currentSpecImports;\n\t\t\t\t});\n\t\t\t});\n\t\t}, {});\n\t}\n\n\tfunction processSpec(scope, spec) {\n\t\tvar instances, components, ready, plugins, id, initialized;\n\n\t\tinstances = scope.instances;\n\t\tcomponents = scope.components;\n\t\tready = {};\n\n\t\t// Setup a promise for each item in this scope\n\t\tfor (id in spec) {\n\t\t\tif(id === '$plugins' || id === 'plugins') {\n\t\t\t\tplugins = spec[id];\n\t\t\t} else if(!object.hasOwn(instances, id)) {\n\t\t\t\t// An initializer may have inserted concrete components\n\t\t\t\t// into the context.  If so, they override components of the\n\t\t\t\t// same name from the input spec\n\t\t\t\tinitialized = defer();\n\t\t\t\tready = defer();\n\t\t\t\tcomponents[id] = scope._createComponentDef(id, spec[id], initialized, ready);\n\t\t\t\tinstances[id] = initialized.promise;\n\t\t\t\tready[id] = ready.promise;\n\t\t\t}\n\t\t}\n\n\t\treturn when.resolve({\n\t\t\tplugins: plugins,\n\t\t\tcomponents: components,\n\t\t\tinstances: instances,\n\t\t\tready: ready\n\t\t});\n\t}\n});\n})(typeof define == 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }\n);","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/lib/array.js":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\n\n(function(define){ 'use strict';\ndefine(function() {\n\n\n\tvar slice = [].slice;\n\n\treturn {\n\t\tdelegate: delegateArray,\n\t\tfromArguments: fromArguments,\n\t\tunion: union\n\t};\n\n\t/**\n\t * Creates a new {Array} with the same contents as array\n\t * @param array {Array}\n\t * @return {Array} a new {Array} with the same contents as array. If array is falsey,\n\t *  returns a new empty {Array}\n\t */\n\tfunction delegateArray(array) {\n\t\treturn array ? [].concat(array) : [];\n\t}\n\n\tfunction fromArguments(args, index) {\n\t\treturn slice.call(args, index||0);\n\t}\n\n\t/**\n\t * Returns a new set that is the union of the two supplied sets\n\t * @param {Array} a1 set\n\t * @param {Array} a2 set\n\t * @returns {Array} union of a1 and a2\n\t */\n\tfunction union(a1, a2) {\n\t\t// If either is empty, return the other\n\t\tif(!a1.length) {\n\t\t\treturn a2.slice();\n\t\t} else if(!a2.length) {\n\t\t\treturn a1.slice();\n\t\t}\n\n\t\treturn a2.reduce(function(union, a2item) {\n\t\t\tif(union.indexOf(a2item) === -1) {\n\t\t\t\tunion.push(a2item);\n\t\t\t}\n\t\t\treturn union;\n\t\t}, a1.slice());\n\t}\n\n});\n})(typeof define == 'function'\n\t// AMD\n\t? define\n\t// CommonJS\n\t: function(factory) { module.exports = factory(); }\n);","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/lib/Map.js":"/** @license MIT License (c) copyright 2010-2013 original author or authors */\n\n/**\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @author: Brian Cavalier\n * @author: John Hann\n */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\tfunction Map() {\n\t\tthis.clear();\n\t}\n\n\tMap.prototype = {\n\t\tget: function(key) {\n\t\t\tvar value, found;\n\t\t\tfound = this._data.some(function(entry) {\n\t\t\t\tif(entry.key === key) {\n\t\t\t\t\tvalue = entry.value;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn found ? value : arguments[1];\n\t\t},\n\n\t\tset: function(key, value) {\n\t\t\tvar replaced = this._data.some(function(entry) {\n\t\t\t\tif(entry.key === key) {\n\t\t\t\t\tentry.value = value;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif(!replaced) {\n\t\t\t\tthis._data.push({ key: key, value: value });\n\t\t\t}\n\t\t},\n\n\t\thas: function(key) {\n\t\t\treturn this._data.some(function(entry) {\n\t\t\t\treturn entry.key === key;\n\t\t\t});\n\t\t},\n\n\t\t'delete': function(key) {\n\t\t\tvar value, found;\n\t\t\tfound = this._data.some(function(entry, i, array) {\n\t\t\t\tif(entry.key === key) {\n\t\t\t\t\tvalue = entry.value;\n\t\t\t\t\tarray.splice(i, 1);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tclear: function() {\n\t\t\tthis._data = [];\n\t\t}\n\t};\n\n\treturn Map;\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/lib/ComponentFactory.js":"/** @license MIT License (c) copyright 2010-2013 original author or authors */\n\n/**\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @author: Brian Cavalier\n * @author: John Hann\n */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar when, object, WireProxy, ObjectProxy, undef;\n\n\twhen = require('when');\n\tobject = require('./object');\n\tWireProxy = require('./WireProxy');\n\tObjectProxy = require('./ObjectProxy');\n\n\tfunction ComponentFactory(lifecycle, plugins, pluginApi) {\n\t\tthis.plugins = plugins;\n\t\tthis.pluginApi = pluginApi;\n\t\tthis.lifecycle = lifecycle;\n\t\tthis.proxies = [];\n\t}\n\n\tComponentFactory.prototype = {\n\n\t\tcreate: function(component) {\n\t\t\tvar found;\n\n\t\t\t// Look for a factory, then use it to create the object\n\t\t\tfound = this.getFactory(component.spec);\n\t\t\treturn found\n\t\t\t\t? this._create(component, found.factory, found.options)\n\t\t\t\t: when.reject(component);\n\t\t},\n\n\t\t_create: function(component, factory, options) {\n\t\t\tvar instance, self;\n\n\t\t\tinstance = when.defer();\n\t\t\tself = this;\n\n\t\t\tfactory(instance.resolver, options,\n\t\t\t\tthis.pluginApi.contextualize(component.id));\n\n\t\t\treturn instance.promise.then(function(instance) {\n\t\t\t\treturn self.processComponent(component, instance);\n\t\t\t});\n\t\t},\n\n\t\tprocessComponent: function(component, instance) {\n\t\t\tvar self, proxy;\n\n\t\t\tself = this;\n\t\t\tproxy = this.createProxy(instance, component);\n\n\t\t\treturn self.initInstance(proxy).then(\n\t\t\t\tfunction(proxy) {\n\t\t\t\t\treturn self.startupInstance(proxy);\n\t\t\t\t}\n\t\t\t);\n\t\t},\n\n\t\tinitInstance: function(proxy) {\n\t\t\treturn this.lifecycle.init(proxy);\n\t\t},\n\n\t\tstartupInstance: function(proxy) {\n\t\t\treturn this.lifecycle.startup(proxy);\n\t\t},\n\n\t\tcreateProxy: function(instance, component) {\n\t\t\tvar proxy;\n\n\t\t\tif (WireProxy.isProxy(instance)) {\n\t\t\t\tproxy = instance;\n\t\t\t\tinstance = WireProxy.getTarget(proxy);\n\t\t\t} else {\n\t\t\t\tproxy = new ObjectProxy(instance);\n\t\t\t}\n\n\t\t\tproxy = this.initProxy(proxy);\n\n\t\t\tif(component) {\n\t\t\t\tcomponent.proxy = proxy;\n\t\t\t\tproxy.id = component.id;\n\t\t\t\tproxy.metadata = component;\n\t\t\t}\n\n\t\t\tthis._registerProxy(proxy);\n\n\t\t\treturn proxy;\n\t\t},\n\n\t\tinitProxy: function(proxy) {\n\n\t\t\tvar proxiers = this.plugins.proxiers;\n\n\t\t\t// Allow proxy plugins to process/modify the proxy\n\t\t\tproxy = proxiers.reduce(\n\t\t\t\tfunction(proxy, proxier) {\n\t\t\t\t\tvar overridden = proxier(proxy);\n\t\t\t\t\treturn WireProxy.isProxy(overridden) ? overridden : proxy;\n\t\t\t\t},\n\t\t\t\tproxy\n\t\t\t);\n\n\t\t\treturn proxy;\n\t\t},\n\n\t\tdestroy: function() {\n\t\t\tvar proxies, lifecycle;\n\n\t\t\tproxies = this.proxies;\n\t\t\tlifecycle = this.lifecycle;\n\n\t\t\treturn shutdownComponents().then(destroyComponents);\n\n\t\t\tfunction shutdownComponents() {\n\t\t\t\treturn when.reduce(proxies,\n\t\t\t\t\tfunction(_, proxy) { return lifecycle.shutdown(proxy); },\n\t\t\t\t\tundef);\n\t\t\t}\n\n\t\t\tfunction destroyComponents() {\n\t\t\t\treturn when.reduce(proxies,\n\t\t\t\t\tfunction(_, proxy) { return proxy.destroy(); },\n\t\t\t\t\tundef);\n\t\t\t}\n\t\t},\n\n\t\t_registerProxy: function(proxy) {\n\t\t\tif(proxy.metadata) {\n\t\t\t\tproxy.path = proxy.metadata.path;\n\t\t\t\tthis.proxies.push(proxy);\n\t\t\t}\n\t\t},\n\n\t\tgetFactory: function(spec) {\n\t\t\tvar f, factories, found;\n\n\t\t\tfactories = this.plugins.factories;\n\n\t\t\tfor (f in factories) {\n\t\t\t\tif (object.hasOwn(spec, f)) {\n\t\t\t\t\tfound = {\n\t\t\t\t\t\tfactory: factories[f],\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\toptions: spec[f],\n\t\t\t\t\t\t\tspec: spec\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Intentionally returns undefined if no factory found\n\t\t\treturn found;\n\n\t\t}\n\t};\n\n\treturn ComponentFactory;\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/lib/WireProxy.js":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\n\n(function(define){ 'use strict';\ndefine(function(require) {\n\n\tvar object, array;\n\n\tobject = require('./object');\n\tarray = require('./array');\n\n\t/**\n\t * A base proxy for all components that wire creates.  It allows wire's\n\t * internals and plugins to work with components using a standard interface.\n\t * WireProxy instances may be extended to specialize the behavior of the\n\t * interface for a particular type of component.  For example, there is a\n\t * specialized version for DOM Nodes.\n\t * @param {*} target value to be proxied\n\t * @constructor\n\t */\n\tfunction WireProxy(target) {\n\t\t// read-only target\n\t\tObject.defineProperty(this, 'target', { value: target });\n\t}\n\n\tWireProxy.prototype = {\n\t\t/**\n\t\t * Get the value of the named property. Sub-types should\n\t\t * override to get properties from their targets in whatever\n\t\t * specialized way is necessary.\n\t\t * @param {string} property\n\t\t * @returns {*} the value or undefined\n\t\t */\n\t\tget: function (property) {\n\t\t\treturn this.target[property];\n\t\t},\n\n\t\t/**\n\t\t * Set the value of the named property. Sub-types should\n\t\t * override to set properties on their targets in whatever\n\t\t * specialized way is necessary.\n\t\t * @param {string} property\n\t\t * @param {*} value\n\t\t * @returns {*}\n\t\t */\n\t\tset: function (property, value) {\n\t\t\tthis.target[property] = value;\n\t\t\treturn value;\n\t\t},\n\n\t\t/**\n\t\t * Invoke the method, with the supplied args, on the proxy's\n\t\t * target. Sub-types should override to invoke methods their\n\t\t * targets in whatever specialized way is necessary.\n\t\t * @param {string|function} method name of method to invoke or\n\t\t *  a function to call using proxy's target as the thisArg\n\t\t * @param {array} args arguments to pass to method\n\t\t * @returns {*} the method's return value\n\t\t */\n\t\tinvoke: function (method, args) {\n\t\t\tvar target = this.target;\n\n\t\t\tif (typeof method === 'string') {\n\t\t\t\tmethod = target[method];\n\t\t\t}\n\n\t\t\treturn method.apply(target, array.fromArguments(args));\n\t\t},\n\n\t\t/**\n\t\t * Add an aspect to the proxy's target. Sub-types should\n\t\t * override to add aspects in whatever specialized way is\n\t\t * necessary.\n\t\t * @param {String|Array|RegExp|Function} pointcut\n\t\t *  expression matching methods to be advised\n\t\t * @param {Object} aspect aspect to add\n\t\t * @returns {{remove:function}} object with remove() that\n\t\t *  will remove the aspect.\n\t\t */\n\t\tadvise: function(pointcut, aspect) {\n\t\t\t/*jshint unused:false*/\n\t\t\tthrow new TypeError('Advice not supported on component type: ' + this.target);\n\t\t},\n\n\t\t/**\n\t\t * Destroy the proxy's target.  Sub-types should override\n\t\t * to destroy their targets in whatever specialized way is\n\t\t * necessary.\n\t\t */\n\t\tdestroy: function() {},\n\n\t\t/**\n\t\t * Attempt to clone this proxy's target. Sub-types should\n\t\t * override to clone their targets in whatever specialized\n\t\t * way is necessary.\n\t\t * @param {object|array|function} thing thing to clone\n\t\t * @param {object} options\n\t\t * @param {boolean} options.deep if true and thing is an Array, try to deep clone its contents\n\t\t * @param {boolean} options.inherited if true and thing is an object, clone inherited and own properties.\n\t\t * @returns {*}\n\t\t */\n\t\tclone: function (options) {\n\t\t\t// don't try to clone a primitive\n\t\t\tvar target = this.target;\n\n\t\t\tif (typeof target == 'function') {\n\t\t\t\t// cloneThing doesn't clone functions, so clone here:\n\t\t\t\treturn target.bind();\n\t\t\t} else if (typeof target != 'object') {\n\t\t\t\treturn target;\n\t\t\t}\n\n\t\t\treturn cloneThing(target, options || {});\n\t\t}\n\t};\n\n\tWireProxy.isProxy = isProxy;\n\tWireProxy.getTarget = getTarget;\n\tWireProxy.extend = extendProxy;\n\n\treturn WireProxy;\n\n\t/**\n\t * Returns a new WireProxy, whose prototype is proxy, with extensions\n\t * as own properties.  This is the \"official\" way to extend the functionality\n\t * of an existing WireProxy.\n\t * @param {WireProxy} proxy proxy to extend\n\t * @param extensions\n\t * @returns {*}\n\t */\n\tfunction extendProxy(proxy, extensions) {\n\t\tif(!isProxy(proxy)) {\n\t\t\tthrow new Error('Cannot extend non-WireProxy');\n\t\t}\n\n\t\treturn object.extend(proxy, extensions);\n\t}\n\n\t/**\n\t * Returns true if it is a WireProxy\n\t * @param {*} it\n\t * @returns {boolean}\n\t */\n\tfunction isProxy(it) {\n\t\treturn it instanceof WireProxy;\n\t}\n\n\t/**\n\t * If it is a WireProxy (see isProxy), returns it's target.  Otherwise,\n\t * returns it;\n\t * @param {*} it\n\t * @returns {*}\n\t */\n\tfunction getTarget(it) {\n\t\treturn isProxy(it) ? it.target : it;\n\t}\n\n\t/**\n\t * Try to clone thing, which can be an object, Array, or Function\n\t * @param {object|array|function} thing thing to clone\n\t * @param {object} options\n\t * @param {boolean} options.deep if true and thing is an Array, try to deep clone its contents\n\t * @param {boolean} options.inherited if true and thing is an object, clone inherited and own properties.\n\t * @returns {array|object|function} cloned thing\n\t */\n\tfunction cloneThing (thing, options) {\n\t\tvar deep, inherited, clone, prop;\n\t\tdeep = options.deep;\n\t\tinherited = options.inherited;\n\n\t\t// Note: this filters out primitive properties and methods\n\t\tif (typeof thing != 'object') {\n\t\t\treturn thing;\n\t\t}\n\t\telse if (thing instanceof Date) {\n\t\t\treturn new Date(thing.getTime());\n\t\t}\n\t\telse if (thing instanceof RegExp) {\n\t\t\treturn new RegExp(thing);\n\t\t}\n\t\telse if (Array.isArray(thing)) {\n\t\t\treturn deep\n\t\t\t\t? thing.map(function (i) { return cloneThing(i, options); })\n\t\t\t\t: thing.slice();\n\t\t}\n\t\telse {\n\t\t\tclone = thing.constructor ? new thing.constructor() : {};\n\t\t\tfor (prop in thing) {\n\t\t\t\tif (inherited || object.hasOwn(thing, prop)) {\n\t\t\t\t\tclone[prop] = deep\n\t\t\t\t\t\t? cloneThing(thing[prop], options)\n\t\t\t\t\t\t: thing[prop];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn clone;\n\t\t}\n\t}\n\n});\n})(typeof define == 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }\n);","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/lib/ObjectProxy.js":"/** @license MIT License (c) copyright 2010-2013 original author or authors */\n\n/**\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @author: Brian Cavalier\n * @author: John Hann\n */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar WireProxy, extend, before, meld, advise, superDestroy;\n\n\tWireProxy = require('./WireProxy');\n\textend = require('./object').extend;\n\tbefore = require('./advice').before;\n\tmeld = require('meld');\n\n\t// FIXME: Remove support for meld.add after deprecation period\n\tadvise = typeof meld === 'function' ? meld : meld.add;\n\n\tsuperDestroy = WireProxy.prototype.destroy;\n\n\tfunction ObjectProxy(target) {\n\t\t/*jshint unused:false*/\n\t\tWireProxy.apply(this, arguments);\n\t}\n\n\tObjectProxy.prototype = extend(WireProxy.prototype, {\n\t\t/**\n\t\t * Add an aspect to the proxy's target. Sub-types should\n\t\t * override to add aspects in whatever specialized way is\n\t\t * necessary.\n\t\t * @param {String|Array|RegExp|Function} pointcut\n\t\t *  expression matching methods to be advised\n\t\t * @param {Object} aspect aspect to add\n\t\t * @returns {{remove:function}} object with remove() that\n\t\t *  will remove the aspect.\n\t\t */\n\t\tadvise: function(pointcut, aspect) {\n\t\t\treturn advise(this.target, pointcut, aspect);\n\t\t}\n\n\n\t});\n\n\treturn ObjectProxy;\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/lib/lifecycle.js":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\n\n(function(define){ 'use strict';\ndefine(function(require) {\n\n\tvar when, safeNonFacetNames;\n\n\twhen = require('when');\n\tsafeNonFacetNames = {\n\t\tid: { value: 1 }\n\t};\n\n\tfunction Lifecycle(plugins, pluginApi) {\n\t\tthis._plugins = plugins;\n\t\tthis._pluginApi = pluginApi;\n\t}\n\n\tLifecycle.prototype = {\n\t\tinit: createLifecyclePhase(['create', 'configure', 'initialize']),\n\t\tstartup: createLifecyclePhase(['connect', 'ready']),\n\t\tshutdown: createLifecyclePhase(['destroy'])\n\t};\n\n\treturn Lifecycle;\n\n\t/**\n\t * Generate a method to process all steps in a lifecycle phase\n\t * @return {Function}\n\t */\n\tfunction createLifecyclePhase(steps) {\n\t\tsteps = generateSteps(steps);\n\n\t\treturn function(proxy) {\n\t\t\tvar plugins, pluginApi;\n\n\t\t\tplugins = this._plugins;\n\t\t\tpluginApi = this._pluginApi.contextualize(proxy.id);\n\n\t\t\treturn when.reduce(steps, function (unused, step) {\n\t\t\t\treturn processFacets(step, proxy, pluginApi, plugins);\n\t\t\t}, proxy);\n\t\t};\n\t}\n\n\tfunction processFacets(step, proxy, api, plugins) {\n\t\tvar promises, metadata, options, name, spec, facets, safeNames, unprocessed;\n\n\t\tpromises = [];\n\t\tmetadata = proxy.metadata;\n\t\tspec = metadata.spec;\n\t\tfacets = plugins.facets;\n\t\tsafeNames = Object.create(plugins.factories, safeNonFacetNames);\n\t\tunprocessed = [];\n\n\t\tfor(name in spec) {\n\t\t\tif(name in facets) {\n\t\t\t\toptions = spec[name];\n\t\t\t\tif (options) {\n\t\t\t\t\tprocessStep(promises, facets[name], step, proxy, options, api);\n\t\t\t\t}\n\t\t\t} else if (!(name in safeNames)) {\n\t\t\t\tunprocessed.push(name);\n\t\t\t}\n\t\t}\n\n\t\tif(unprocessed.length) {\n\t\t\treturn when.reject(unrecognizedFacets(proxy, unprocessed, spec));\n\t\t} else {\n\t\t\treturn when.all(promises).then(function () {\n\t\t\t\treturn processListeners(step, proxy, api, plugins.listeners);\n\t\t\t}).yield(proxy);\n\t\t}\n\t}\n\n\tfunction processListeners(step, proxy, api, listeners) {\n\t\tvar listenerPromises = [];\n\n\t\tfor (var i = 0; i < listeners.length; i++) {\n\t\t\tprocessStep(listenerPromises, listeners[i], step, proxy, {}, api);\n\t\t}\n\n\t\treturn when.all(listenerPromises);\n\t}\n\n\tfunction processStep(promises, processor, step, proxy, options, api) {\n\t\tvar facet, pendingFacet;\n\n\t\tif (processor && processor[step]) {\n\t\t\tpendingFacet = when.defer();\n\t\t\tpromises.push(pendingFacet.promise);\n\n\t\t\tfacet = Object.create(proxy);\n\t\t\tfacet.options = options;\n\t\t\tprocessor[step](pendingFacet.resolver, facet, api);\n\t\t}\n\t}\n\n\tfunction generateSteps(steps) {\n\t\treturn steps.reduce(reduceSteps, []);\n\t}\n\n\tfunction reduceSteps(lifecycle, step) {\n\t\tlifecycle.push(step + ':before');\n\t\tlifecycle.push(step);\n\t\tlifecycle.push(step + ':after');\n\t\treturn lifecycle;\n\t}\n\n\tfunction unrecognizedFacets(proxy, unprocessed, spec) {\n\t\treturn new Error('unrecognized facets in ' + proxy.id + ', maybe you forgot a plugin? ' + unprocessed.join(', ') + '\\n' + JSON.stringify(spec));\n\t}\n\n});\n})(typeof define == 'function'\n\t// AMD\n\t? define\n\t// CommonJS\n\t: function(factory) { module.exports = factory(require); }\n);","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/lib/resolver.js":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\n\n(function(define){ 'use strict';\ndefine(function(require) {\n\n\tvar when, object;\n\n\twhen = require('when');\n\tobject = require('./object');\n\n\t/**\n\t * Create a reference resolve that uses the supplied plugins and pluginApi\n\t * @param {object} config\n\t * @param {object} config.plugins plugin registry\n\t * @param {object} config.pluginApi plugin Api to provide to resolver plugins\n\t *  when resolving references\n\t * @constructor\n\t */\n\tfunction Resolver(resolvers, pluginApi) {\n\t\tthis._resolvers = resolvers;\n\t\tthis._pluginApi = pluginApi;\n\t}\n\n\tResolver.prototype = {\n\n\t\t/**\n\t\t * Determine if it is a reference spec that can be resolved by this resolver\n\t\t * @param {*} it\n\t\t * @return {boolean} true iff it is a reference\n\t\t */\n\t\tisRef: function(it) {\n\t\t\treturn it && object.hasOwn(it, '$ref');\n\t\t},\n\n\t\t/**\n\t\t * Parse it, which must be a reference spec, into a reference object\n\t\t * @param {object|string} it\n\t\t * @param {string?} it.$ref\n\t\t * @return {object} reference object\n\t\t */\n\t\tparse: function(it) {\n\t\t\treturn this.isRef(it)\n\t\t\t\t? this.create(it.$ref, it)\n\t\t\t\t: this.create(it, {});\n\t\t},\n\n\t\t/**\n\t\t * Creates a reference object\n\t\t * @param {string} name reference name\n\t\t * @param {object} options\n\t\t * @return {{resolver: String, name: String, options: object, resolve: Function}}\n\t\t */\n\t\tcreate: function(name, options) {\n\t\t\tvar self, split, resolver;\n\n\t\t\tself = this;\n\n\t\t\tsplit = name.indexOf('!');\n\t\t\tresolver = name.substring(0, split);\n\t\t\tname = name.substring(split + 1);\n\n\t\t\treturn {\n\t\t\t\tresolver: resolver,\n\t\t\t\tname: name,\n\t\t\t\toptions: options,\n\t\t\t\tresolve: function(fallback, onBehalfOf) {\n\t\t\t\t\treturn this.resolver\n\t\t\t\t\t\t? self._resolve(resolver, name, options, onBehalfOf)\n\t\t\t\t\t\t: fallback(name, options);\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Do the work of resolving a reference using registered plugins\n\t\t * @param {string} resolverName plugin resolver name (e.g. \"dom\"), the part before the \"!\"\n\t\t * @param {string} name reference name, the part after the \"!\"\n\t\t * @param {object} options additional options to pass thru to a resolver plugin\n\t\t * @param {string|*} onBehalfOf some indication of another component on whose behalf this\n\t\t *  reference is being resolved.  Used to build a reference graph and detect cycles\n\t\t * @return {object} promise for the resolved reference\n\t\t * @private\n\t\t */\n\t\t_resolve: function(resolverName, name, options, onBehalfOf) {\n\t\t\tvar deferred, resolver, api;\n\n\t\t\tdeferred = when.defer();\n\n\t\t\tif (resolverName) {\n\t\t\t\tresolver = this._resolvers[resolverName];\n\n\t\t\t\tif (resolver) {\n\t\t\t\t\tapi = this._pluginApi.contextualize(onBehalfOf);\n\t\t\t\t\tresolver(deferred.resolver, name, options||{}, api);\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.reject(new Error('No resolver plugin found: ' + resolverName));\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tdeferred.reject(new Error('Cannot resolve ref: ' + name));\n\t\t\t}\n\n\t\t\treturn deferred.promise;\n\t\t}\n\t};\n\n\treturn Resolver;\n\n});\n})(typeof define == 'function'\n\t// AMD\n\t? define\n\t// CommonJS\n\t: function(factory) { module.exports = factory(require); }\n);","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/lib/plugin/registry.js":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * plugins\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n * @author: brian@hovercraftstudios.com\n */\n(function(define) {\ndefine(function(require) {\n\n\tvar when, array, object, priority, instantiate, nsKey, nsSeparator;\n\n\twhen = require('when');\n\tarray = require('../array');\n\tobject = require('../object');\n\tpriority = require('./priority');\n\tinstantiate = require('../instantiate');\n\n\tnsKey = '$ns';\n\tnsSeparator = ':';\n\n\tfunction PluginRegistry() {\n\t\tthis.plugins = [];\n\t\tthis._namespaces = {};\n\n\t\tthis.contextListeners = [];\n\t\tthis.listeners = [];\n\t\tthis.proxiers =  [];\n\t\tthis.resolvers = {};\n\t\tthis.factories = {};\n\t\tthis.facets =    {};\n\t}\n\n\tPluginRegistry.prototype = {\n\t\tscanModule: function (module, spec, namespace) {\n\t\t\tvar self, pluginFactory;\n\n\t\t\tpluginFactory = discoverPlugin(module);\n\n\t\t\tif (!allowPlugin(pluginFactory, this.plugins)) {\n\t\t\t\treturn when.resolve();\n\t\t\t}\n\n\t\t\t// Add to singleton plugins list to only allow one instance\n\t\t\t// of this plugin in the current context.\n\t\t\tthis.plugins.push(pluginFactory);\n\n\t\t\t// Initialize the plugin for this context\n\t\t\tself = this;\n\t\t\treturn when(instantiate(pluginFactory, [spec]),\n\t\t\t\tfunction (plugin) {\n\t\t\t\t\tplugin && self.registerPlugin(plugin, namespace || getNamespace(spec));\n\t\t\t\t}\n\t\t\t).yield();\n\t\t},\n\n\t\tregisterPlugin: function (plugin, namespace) {\n\t\t\taddNamespace(namespace, this._namespaces);\n\n\t\t\taddPlugin(plugin.resolvers, this.resolvers, namespace);\n\t\t\taddPlugin(plugin.factories, this.factories, namespace);\n\t\t\taddPlugin(plugin.facets, this.facets, namespace);\n\n\t\t\tthis.listeners.push(plugin);\n\t\t\tif(plugin.context) {\n\t\t\t\tthis.contextListeners.push(plugin.context);\n\t\t\t}\n\n\t\t\tthis._registerProxies(plugin.proxies);\n\t\t},\n\n\t\t_registerProxies: function (proxiesToAdd) {\n\t\t\tif (!proxiesToAdd) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.proxiers = priority.sortReverse(array.union(this.proxiers, proxiesToAdd));\n\t\t}\n\t};\n\n\treturn PluginRegistry;\n\n\tfunction discoverPlugin(module) {\n\t\tvar plugin;\n\n\t\t// Prefer deprecated legacy wire$plugin format over newer\n\t\t// plain function format.\n\t\t// TODO: Remove support for wire$plugin\n\t\tif(typeof module.wire$plugin === 'function') {\n\t\t\tplugin = module.wire$plugin;\n\t\t} else if(typeof module === 'function') {\n\t\t\tplugin = module;\n\t\t}\n\n\t\treturn plugin;\n\t}\n\n\tfunction getNamespace(spec) {\n\t\tvar namespace;\n\t\tif(typeof spec === 'object' && nsKey in spec) {\n\t\t\t// A namespace was provided\n\t\t\tnamespace = spec[nsKey];\n\t\t}\n\n\t\treturn namespace;\n\t}\n\n\tfunction addNamespace(namespace, namespaces) {\n\t\tif(namespace && namespace in namespaces) {\n\t\t\tthrow new Error('plugin namespace already in use: ' + namespace);\n\t\t} else {\n\t\t\tnamespaces[namespace] = 1;\n\t\t}\n\t}\n\n\tfunction allowPlugin(plugin, existing) {\n\t\treturn typeof plugin === 'function' && existing.indexOf(plugin) === -1;\n\t}\n\n\tfunction addPlugin(src, registry, namespace) {\n\t\tvar newPluginName, namespacedName;\n\t\tfor (newPluginName in src) {\n\t\t\tnamespacedName = makeNamespace(newPluginName, namespace);\n\t\t\tif (object.hasOwn(registry, namespacedName)) {\n\t\t\t\tthrow new Error('Two plugins for same type in scope: ' + namespacedName);\n\t\t\t}\n\n\t\t\tregistry[namespacedName] = src[newPluginName];\n\t\t}\n\t}\n\n\tfunction makeNamespace(pluginName, namespace) {\n\t\treturn namespace ? (namespace + nsSeparator + pluginName) : pluginName;\n\t}\n});\n}(typeof define === 'function' ? define : function(factory) { module.exports = factory(require); }));\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/lib/plugin/priority.js":"/** @license MIT License (c) copyright 2010-2013 original author or authors */\n\n/**\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @author: Brian Cavalier\n * @author: John Hann\n */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\tvar basePriority, defaultPriority;\n\n\tbasePriority = -99;\n\tdefaultPriority = 0;\n\n\treturn {\n\t\tbasePriority: basePriority,\n\t\tsortReverse: prioritizeReverse\n\t};\n\n\tfunction prioritizeReverse(list) {\n\t\treturn list.sort(byReversePriority);\n\t}\n\n\tfunction byReversePriority(a, b) {\n\t\tvar aPriority, bPriority;\n\n\t\taPriority = a.priority || defaultPriority;\n\t\tbPriority = b.priority || defaultPriority;\n\n\t\treturn aPriority < bPriority ? -1\n\t\t\t: aPriority > bPriority ? 1 : 0;\n\t}\n\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/lib/instantiate.js":"/** @license MIT License (c) copyright original author or authors */\n\n/**\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\n\n(function(define){ 'use strict';\ndefine(function() {\n\n\tvar undef;\n\n\t/**\n\t * Creates an object by either invoking ctor as a function and returning the result,\n\t * or by calling new ctor().  It uses a simple heuristic to try to guess which approach\n\t * is the \"right\" one.\n\t *\n\t * @param ctor {Function} function or constructor to invoke\n\t * @param args {Array} array of arguments to pass to ctor in either case\n\t *\n\t * @return The result of invoking ctor with args, with or without new, depending on\n\t * the strategy selected.\n\t */\n\treturn function instantiate(ctor, args, forceConstructor) {\n\n\t\tvar begotten, ctorResult;\n\n\t\tif (forceConstructor || (forceConstructor === undef && isConstructor(ctor))) {\n\t\t\tbegotten = Object.create(ctor.prototype);\n\t\t\tdefineConstructorIfPossible(begotten, ctor);\n\t\t\tctorResult = ctor.apply(begotten, args);\n\t\t\tif(ctorResult !== undef) {\n\t\t\t\tbegotten = ctorResult;\n\t\t\t}\n\n\t\t} else {\n\t\t\tbegotten = ctor.apply(undef, args);\n\n\t\t}\n\n\t\treturn begotten === undef ? null : begotten;\n\t};\n\n\t/**\n\t * Carefully sets the instance's constructor property to the supplied\n\t * constructor, using Object.defineProperty if available.  If it can't\n\t * set the constructor in a safe way, it will do nothing.\n\t *\n\t * @param instance {Object} component instance\n\t * @param ctor {Function} constructor\n\t */\n\tfunction defineConstructorIfPossible(instance, ctor) {\n\t\ttry {\n\t\t\tObject.defineProperty(instance, 'constructor', {\n\t\t\t\tvalue: ctor,\n\t\t\t\tenumerable: false\n\t\t\t});\n\t\t} catch(e) {\n\t\t\t// If we can't define a constructor, oh well.\n\t\t\t// This can happen if in envs where Object.defineProperty is not\n\t\t\t// available, or when using cujojs/poly or other ES5 shims\n\t\t}\n\t}\n\n\t/**\n\t * Determines whether the supplied function should be invoked directly or\n\t * should be invoked using new in order to create the object to be wired.\n\t *\n\t * @param func {Function} determine whether this should be called using new or not\n\t *\n\t * @returns {Boolean} true iff func should be invoked using new, false otherwise.\n\t */\n\tfunction isConstructor(func) {\n\t\tvar is = false, p;\n\t\tfor (p in func.prototype) {\n\t\t\tif (p !== undef) {\n\t\t\t\tis = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn is;\n\t}\n\n});\n})(typeof define == 'function'\n\t// AMD\n\t? define\n\t// CommonJS\n\t: function(factory) {\n\t\tmodule.exports = factory();\n\t}\n);\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/lib/specUtils.js":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @author: Brian Cavalier\n * @author: John Hann\n */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar object, when;\n\n\twhen = require('when');\n\tobject = require('./object');\n\n\tfunction mergeSpecs(moduleLoader, specs) {\n\t\treturn when(specs, function(specs) {\n\t\t\treturn when.resolve(Array.isArray(specs)\n\t\t\t\t? mergeAll(moduleLoader, specs)\n\t\t\t\t: (typeof specs === 'string' ? moduleLoader(specs) : specs));\n\t\t});\n\t}\n\n\tfunction mergeAll(moduleLoader, specs) {\n\t\treturn when.reduce(specs, function(merged, module) {\n\t\t\treturn typeof module == 'string'\n\t\t\t\t? when(moduleLoader(module), function(spec) { return object.mixin(merged, spec); })\n\t\t\t\t: object.mixin(merged, module);\n\t\t}, {});\n\t}\n\n\treturn {\n\t\tmergeSpecs: mergeSpecs,\n\t\tmergeAll: mergeAll\n\t};\n});\n})(typeof define == 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }\n);","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/lib/graph/DirectedGraph.js":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * DirectedGraph\n * @author: brian@hovercraftstudios.com\n */\n(function(define) {\ndefine(function() {\n\n\t/**\n\t * A simple directed graph\n\t * @constructor\n\t */\n\tfunction DirectedGraph() {\n\t\tthis.vertices = {};\n\t}\n\n\tDirectedGraph.prototype = {\n\t\t/**\n\t\t * Add a new edge from one vertex to another\n\t\t * @param {string} from vertex at the tail of the edge\n\t\t * @param {string} to vertex at the head of the edge\n\t\t */\n\t\taddEdge: function(from, to) {\n\t\t\tthis._getOrCreateVertex(to);\n\t\t\tthis._getOrCreateVertex(from).edges[to] = 1;\n\t\t},\n\n\t\t/**\n\t\t * Adds and initializes new vertex, or returns an existing vertex\n\t\t * if one with the supplied name already exists\n\t\t * @param {string} name vertex name\n\t\t * @return {object} the new vertex, with an empty edge set\n\t\t * @private\n\t\t */\n\t\t_getOrCreateVertex: function(name) {\n\t\t\tvar v = this.vertices[name];\n\t\t\tif(!v) {\n\t\t\t\tv = this.vertices[name] = { name: name, edges: {} };\n\t\t\t}\n\n\t\t\treturn v;\n\t\t},\n\n\t\t/**\n\t\t * Removes an edge, if it exits\n\t\t * @param {string} from vertex at the tail of the edge\n\t\t * @param {string} to vertex at the head of the edge\n\t\t */\n\t\tremoveEdge: function(from, to) {\n\t\t\tvar outbound = this.vertices[from];\n\t\t\tif(outbound) {\n\t\t\t\tdelete outbound.edges[to];\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Calls lambda once for each vertex in the graph passing\n\t\t * the vertex as the only param.\n\t\t * @param {function} lambda\n\t\t */\n\t\teachVertex: function(lambda) {\n\t\t\tvar vertices, v;\n\n\t\t\tvertices = this.vertices;\n\t\t\tfor(v in vertices) {\n\t\t\t\tlambda(vertices[v]);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Calls lambda once for every outbound edge of the supplied vertex\n\t\t * @param {string} vertex vertex name whose edges will be passed to lambda\n\t\t * @param {function} lambda\n\t\t */\n\t\teachEdgeFrom: function(vertex, lambda) {\n\t\t\tvar v, e, vertices;\n\n\t\t\tvertices = this.vertices;\n\t\t\tv = vertices[vertex];\n\n\t\t\tif(!v) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor(e in v.edges) {\n\t\t\t\tlambda(v, vertices[e]);\n\t\t\t}\n\t\t}\n\t};\n\n\treturn DirectedGraph;\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/lib/graph/cyclesTracker.js":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * cyclesTracker\n * @author: brian@hovercraftstudios.com\n * @author: younes.ouadi@gmail.com\n */\n(function(define) {\ndefine(function(require) {\n\n\tvar findStronglyConnected, formatCycles;\n\n\tfindStronglyConnected = require('./tarjan');\n\tformatCycles = require('./formatCycles');\n\n\t/**\n\t * Make sure that the new name doesn't introduce a cycle.\n\t * \n\t * @param {string} name the name being used.\n\t * @param {string} onBehalfOf some indication of another name on whose behalf this\n\t *  name is being used.  Used to build graph and detect cycles\n\t * @return {string} the name being used.\n\t */\n\tfunction ensureNoCycles(namesGraph, name, onBehalfOf) {\n\t\tvar stronglyConnected, cycles;\n\n\t\t// add the name to the graph\n\t\tonBehalfOf = onBehalfOf||'?';\n\t\tnamesGraph.addEdge(onBehalfOf, name);\n\n\t\t// compute cycles\n\t\tstronglyConnected = findStronglyConnected(namesGraph);\n\t\tcycles = stronglyConnected.filter(function(node) {\n\t\t\t// Only consider cycles that:\n\t\t\t// * have more than one node\n\t\t\t// * have one node and that node is not self-referenced\n\t\t\treturn node.length > 1 || (node.length === 1 && Object.keys(node[0].edges).indexOf(node[0].name) !== -1);\n\t\t});\n\n\t\t// is there a cycle?\n\t\tif(cycles.length) {\n\t\t\t// Cycles detected\n\t\t\tthrow new Error('Possible circular usage:\\n' + formatCycles(cycles));\n\t\t}\n\n\t\treturn name;\n\t}\n\n\treturn {\n\t\tensureNoCycles: ensureNoCycles\n\t};\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/lib/graph/tarjan.js":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * Tarjan directed graph cycle detection\n * @author: brian@hovercraftstudios.com\n */\n(function(define) {\ndefine(function() {\n\n\tvar undef;\n\n\t/**\n\t * Tarjan directed graph cycle detection.\n\t * See http://en.wikipedia.org/wiki/Tarjan's_strongly_connected_components_algorithm\n\t *\n\t * WARNING: For efficiency, this adds properties to the vertices in the\n\t * graph.  It doesn't really matter for wire's internal purposes.\n\t *\n\t * @param {DirectedGraph} digraph\n\t * @return {Array} each element is a set (Array) of vertices involved\n\t * in a cycle.\n\t */\n\treturn function tarjan(digraph) {\n\n\t\tvar index, stack, scc;\n\n\t\tindex = 0;\n\t\tstack = [];\n\n\t\tscc = [];\n\n\t\t// Clear out any old cruft that may be hanging around\n\t\t// from a previous run.  Maybe should do this afterward?\n\t\tdigraph.eachVertex(function(v) {\n\t\t\tdelete v.index;\n\t\t\tdelete v.lowlink;\n\t\t\tdelete v.onStack;\n\t\t});\n\n\t\t// Start the depth first search\n\t\tdigraph.eachVertex(function(v) {\n\t\t\tif(v.index === undef) {\n\t\t\t\tfindStronglyConnected(digraph, v);\n\t\t\t}\n\t\t});\n\n\t\t// Tarjan algorithm for a single node\n\t\tfunction findStronglyConnected(dg, v) {\n\t\t\tvar vertices, vertex;\n\n\t\t\tv.index = v.lowlink = index;\n\t\t\tindex += 1;\n\t\t\tpushStack(stack, v);\n\n\t\t\tdg.eachEdgeFrom(v.name, function(v, w) {\n\n\t\t\t\tif(w.index === undef) {\n\t\t\t\t\t// Continue depth first search\n\t\t\t\t\tfindStronglyConnected(dg, w);\n\t\t\t\t\tv.lowlink = Math.min(v.lowlink, w.lowlink);\n\t\t\t\t} else if(w.onStack) {\n\t\t\t\t\tv.lowlink = Math.min(v.lowlink, w.index);\n\t\t\t\t}\n\n\t\t\t});\n\n\t\t\tif(v.lowlink === v.index) {\n\t\t\t\tvertices = [];\n\t\t\t\tif(stack.length) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tvertex = popStack(stack);\n\t\t\t\t\t\tvertices.push(vertex);\n\t\t\t\t\t} while(v !== vertex);\n\t\t\t\t}\n\n\t\t\t\tif(vertices.length) {\n\t\t\t\t\tscc.push(vertices);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn scc;\n\t};\n\n\t/**\n\t * Push a vertex on the supplied stack, but also tag the\n\t * vertex as being on the stack so we don't have to scan the\n\t * stack later in order to tell.\n\t * @param {Array} stack\n\t * @param {object} vertex\n\t */\n\tfunction pushStack(stack, vertex) {\n\t\tstack.push(vertex);\n\t\tvertex.onStack = 1;\n\t}\n\n\t/**\n\t * Pop an item off the supplied stack, being sure to un-tag it\n\t * @param {Array} stack\n\t * @return {object|undefined} vertex\n\t */\n\tfunction popStack(stack) {\n\t\tvar v = stack.pop();\n\t\tif(v) {\n\t\t\tdelete v.onStack;\n\t\t}\n\n\t\treturn v;\n\t}\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/lib/graph/formatCycles.js":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * formatCycles\n * @author: brian@hovercraftstudios.com\n */\n(function(define) {\ndefine(function() {\n\t/**\n\t * If there are cycles, format them for output\n\t * @param {Array} cycles array of reference resolution cycles\n\t * @return {String} formatted string\n\t */\n\treturn function formatCycles(cycles) {\n\t\treturn cycles.map(function (sc) {\n\t\t\treturn '[' + sc.map(function (v) {\n\t\t\t\t\treturn v.name;\n\t\t\t\t}\n\t\t\t).join(', ') + ']';\n\t\t}).join(', ');\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/lib/plugin/defaultPlugins.js":"/**\n * defaultPlugins\n * @author: brian\n */\n(function(define) {\ndefine(function(require) {\n\n\treturn [\n\t\trequire('./wirePlugin'),\n\t\trequire('./basePlugin')\n\t];\n\n});\n}(typeof define === 'function' ? define : function(factory) { module.exports = factory(require); }));\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/lib/plugin/wirePlugin.js":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * Plugin that allows wire to be used as a plugin within a wire spec\n *\n * wire is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\n\n(function(define) {\ndefine(function(require) {\n\n\tvar when, object;\n\n\twhen = require('when');\n\tobject = require('../object');\n\n\treturn function(/* options */) {\n\n\t\tvar ready = when.defer();\n\n\t\treturn {\n\t\t\tcontext: {\n\t\t\t\tready: function(resolver) {\n\t\t\t\t\tready.resolve();\n\t\t\t\t\tresolver.resolve();\n\t\t\t\t}\n\t\t\t},\n\t\t\tresolvers: {\n\t\t\t\twire: wireResolver\n\t\t\t},\n\t\t\tfactories: {\n\t\t\t\twire: wireFactory\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Factory that creates either a child context, or a *function* that will create\n\t\t * that child context.  In the case that a child is created, this factory returns\n\t\t * a promise that will resolve when the child has completed wiring.\n\t\t *\n\t\t * @param {Object} resolver used to resolve with the created component\n\t\t * @param {Object} componentDef component spec for the component to be created\n\t\t * @param {function} wire scoped wire function\n\t\t */\n\t\tfunction wireFactory(resolver, componentDef, wire) {\n\t\t\tvar options, module, provide, defer, waitParent, result;\n\n\t\t\toptions = componentDef.options;\n\n\t\t\t// Get child spec and options\n\t\t\tif(object.isObject(options) && 'spec' in options) {\n\t\t\t\tmodule = options.spec;\n\t\t\t\twaitParent = options.waitParent;\n\t\t\t\tdefer = options.defer;\n\t\t\t\tprovide = options.provide;\n\t\t\t} else {\n\t\t\t\tmodule = options;\n\t\t\t}\n\n\t\t\tfunction init(context) {\n\t\t\t\tvar initialized;\n\n\t\t\t\tif(provide) {\n\t\t\t\t\tinitialized = when(wire(provide), function(provides) {\n\t\t\t\t\t\tobject.mixin(context.instances, provides);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn initialized;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Create a child context of the current context\n\t\t\t * @param {object?} mixin additional spec to be mixed into\n\t\t\t *  the child being wired\n\t\t\t * @returns {Promise} promise for child context\n\t\t\t */\n\t\t\tfunction createChild(/** {Object|String}? */ mixin) {\n\t\t\t\tvar spec, config;\n\n\t\t\t\tspec = mixin ? [].concat(module, mixin) : module;\n\t\t\t\tconfig = { initializers: [init] };\n\n\t\t\t\tvar child = wire.createChild(spec, config);\n\t\t\t\treturn defer ? child\n\t\t\t\t\t: when(child, function(child) {\n\t\t\t\t\treturn object.hasOwn(child, '$exports') ? child.$exports : child;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (defer) {\n\t\t\t\t// Resolve with the createChild *function* itself\n\t\t\t\t// which can be used later to wire the spec\n\t\t\t\tresult = createChild;\n\n\t\t\t} else if(waitParent) {\n\n\t\t\t\tvar childPromise = when(ready.promise, function() {\n\t\t\t\t\t// ensure nothing is passed to createChild here\n\t\t\t\t\treturn createChild();\n\t\t\t\t});\n\n\t\t\t\tresult = wrapChild(childPromise);\n\n\t\t\t} else {\n\t\t\t\tresult = createChild();\n\t\t\t}\n\n\t\t\tresolver.resolve(result);\n\t\t}\n\t};\n\n\tfunction wrapChild(promise) {\n\t\treturn { promise: promise };\n\t}\n\n\t/**\n\t * Builtin reference resolver that resolves to the context-specific\n\t * wire function.\n\t */\n\tfunction wireResolver(resolver, _, __, wire) {\n\t\tresolver.resolve(wire.createChild);\n\t}\n\n});\n}(typeof define === 'function' ? define : function(factory) { module.exports = factory(require); }));\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/lib/plugin/basePlugin.js":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * Base wire plugin that provides properties, init, and destroy facets, and\n * a proxy for plain JS objects.\n *\n * wire is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar when, object, functional, pipeline, instantiate, createInvoker,\n\t\twhenAll, obj, pluginInstance, undef;\n\n\twhen = require('when');\n\tobject = require('../object');\n\tfunctional = require('../functional');\n\tpipeline = require('../pipeline');\n\tinstantiate = require('../instantiate');\n\tcreateInvoker = require('../invoker');\n\n\twhenAll = when.all;\n\n\tobj = {};\n\n\tfunction asArray(it) {\n\t\treturn Array.isArray(it) ? it : [it];\n\t}\n\n\tfunction invoke(func, proxy, args, wire) {\n        return when(wire(args, func, proxy.path),\n\t\t\tfunction (resolvedArgs) {\n\t\t\t\treturn proxy.invoke(func, asArray(resolvedArgs));\n\t\t\t}\n\t\t);\n\t}\n\n\tfunction invokeAll(facet, wire) {\n\t\tvar options = facet.options;\n\n\t\tif(typeof options == 'string') {\n\t\t\treturn invoke(options, facet, [], wire);\n\n\t\t} else {\n\t\t\tvar promises, funcName;\n\t\t\tpromises = [];\n\n\t\t\tfor(funcName in options) {\n\t\t\t\tpromises.push(invoke(funcName, facet, options[funcName], wire));\n\t\t\t}\n\n\t\t\treturn whenAll(promises);\n\t\t}\n\t}\n\n\t//\n\t// Mixins\n\t//\n\n\tfunction mixin(target, src) {\n\t\tvar name, s;\n\n\t\tfor(name in src) {\n\t\t\ts = src[name];\n\t\t\tif(!(name in target) || (target[name] !== s && (!(name in obj) || obj[name] !== s))) {\n\t\t\t\ttarget[name] = s;\n\t\t\t}\n\t\t}\n\n\t\treturn target;\n\t}\n\n\tfunction doMixin(target, introduction, wire) {\n\t\tintroduction = typeof introduction == 'string'\n\t\t\t? wire.resolveRef(introduction)\n\t\t\t: wire(introduction);\n\n\t\treturn when(introduction, mixin.bind(null, target));\n\t}\n\n\tfunction mixinFacet(resolver, facet, wire) {\n\t\tvar target, intros;\n\n\t\ttarget = facet.target;\n\t\tintros = facet.options;\n\n\t\tif(!Array.isArray(intros)) {\n\t\t\tintros = [intros];\n\t\t}\n\n\t\tresolver.resolve(when.reduce(intros, function(target, intro) {\n\t\t\treturn doMixin(target, intro, wire);\n\t\t}, target));\n\t}\n\n    /**\n     * Factory that handles cases where you need to create an object literal\n     * that has a property whose name would trigger another wire factory.\n     * For example, if you need an object literal with a property named \"create\",\n     * which would normally cause wire to try to construct an instance using\n     * a constructor or other function, and will probably result in an error,\n     * or an unexpected result:\n     * myObject: {\n     *      create: \"foo\"\n     *    ...\n     * }\n     *\n     * You can use the literal factory to force creation of an object literal:\n     * myObject: {\n     *    literal: {\n     *      create: \"foo\"\n     *    }\n     * }\n     *\n     * which will result in myObject.create == \"foo\" rather than attempting\n     * to create an instance of an AMD module whose id is \"foo\".\n     */\n\tfunction literalFactory(resolver, spec /*, wire */) {\n\t\tresolver.resolve(spec.options);\n\t}\n\n\t/**\n\t * @deprecated Use create (instanceFactory) instead\n\t * @param resolver\n\t * @param componentDef\n\t * @param wire\n\t */\n\tfunction protoFactory(resolver, componentDef, wire) {\n\t\tvar parentRef, promise;\n\n        parentRef = componentDef.options;\n\n        promise = typeof parentRef === 'string'\n                ? wire.resolveRef(parentRef)\n                : wire(parentRef);\n\n\t\tresolver.resolve(promise.then(Object.create));\n\t}\n\n\tfunction propertiesFacet(resolver, facet, wire) {\n\n\t\tvar properties, path, setProperty, propertiesSet;\n\n\t\tproperties = facet.options;\n\t\tpath = facet.path;\n\t\tsetProperty = facet.set.bind(facet);\n\n\t\tpropertiesSet = when.map(Object.keys(facet.options), function(key) {\n\t\t\treturn wire(properties[key], facet.path)\n\t\t\t\t.then(function(wiredProperty) {\n\t\t\t\t\tsetProperty(key, wiredProperty);\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\n\t\tresolver.resolve(propertiesSet);\n\t}\n\n\tfunction invokerFactory(resolver, componentDef, wire) {\n\n\t\tvar invoker = wire(componentDef.options).then(function (invokerContext) {\n\t\t\t// It'd be nice to use wire.getProxy() then proxy.invoke()\n\t\t\t// here, but that means the invoker must always return\n\t\t\t// a promise.  Not sure that's best, so for now, just\n\t\t\t// call the method directly\n\t\t\treturn createInvoker(invokerContext.method, invokerContext.args);\n\t\t});\n\n\t\tresolver.resolve(invoker);\n\t}\n\n\tfunction invokerFacet(resolver, facet, wire) {\n\t\tresolver.resolve(invokeAll(facet, wire));\n\t}\n\n\tfunction cloneFactory(resolver, componentDef, wire) {\n\t\tvar sourceRef, options, cloned;\n\n\t\tif (wire.resolver.isRef(componentDef.options.source)) {\n\t\t\tsourceRef = componentDef.options.source;\n\t\t\toptions = componentDef.options;\n\t\t}\n\t\telse {\n\t\t\tsourceRef = componentDef.options;\n\t\t\toptions = {};\n\t\t}\n\n\t\tcloned = wire(sourceRef).then(function (ref) {\n\t\t\treturn when(wire.getProxy(ref), function (proxy) {\n\t\t\t\tif (!proxy.clone) {\n\t\t\t\t\tthrow new Error('No clone function found for ' + componentDef.id);\n\t\t\t\t}\n\n\t\t\t\treturn proxy.clone(options);\n\t\t\t});\n\t\t});\n\n\t\tresolver.resolve(cloned);\n\t}\n\n\tfunction getArgs(create, wire) {\n\t\treturn create.args ? wire(asArray(create.args)) : [];\n\t}\n\n\tfunction moduleFactory(resolver, componentDef, wire) {\n\t\tresolver.resolve(wire.loadModule(componentDef.options));\n\t}\n\n\t/**\n\t * Factory that uses an AMD module either directly, or as a\n\t * constructor or plain function to create the resulting item.\n\t *\n\t * @param {Object} resolver resolver to resolve with the created component\n\t * @param {Object} componentDef portion of the spec for the component to be created\n\t * @param {function} wire\n\t */\n\tfunction instanceFactory(resolver, componentDef, wire) {\n\t\tvar create, args, isConstructor, module, instance;\n\n\t\tcreate = componentDef.options;\n\n\t\tif (typeof create == 'string') {\n\t\t\tmodule = wire.loadModule(create);\n\t\t} else if(wire.resolver.isRef(create)) {\n\t\t\tmodule = wire(create);\n\t\t\targs = getArgs(create, wire);\n\t\t} else if(object.isObject(create) && create.module) {\n\t\t\tmodule = wire.resolver.isRef(create.module)\n\t\t\t\t? wire(create.module)\n\t\t\t\t: wire.loadModule(create.module);\n\t\t\targs = getArgs(create, wire);\n\t\t\tisConstructor = create.isConstructor;\n\t\t} else {\n\t\t\tmodule = create;\n\t\t}\n\n\t\tinstance = when.join(module, args).spread(createInstance);\n\n\t\tresolver.resolve(instance);\n\n\t\t// Load the module, and use it to create the object\n\t\tfunction createInstance(module, args) {\n\t\t\t// We'll either use the module directly, or we need\n\t\t\t// to instantiate/invoke it.\n\t\t\treturn typeof module == 'function'\n\t\t\t\t? instantiate(module, args, isConstructor)\n\t\t\t\t: Object.create(module);\n\t\t}\n\t}\n\n\tfunction composeFactory(resolver, componentDef, wire) {\n\t\tvar options, promise;\n\n\t\toptions = componentDef.options;\n\n\t\tif(typeof options == 'string') {\n\t\t\tpromise = pipeline(undef, options, wire);\n\t\t} else {\n\t\t\t// Assume it's an array of things that will wire to functions\n\t\t\tpromise = when(wire(options), function(funcArray) {\n\t\t\t\treturn functional.compose(funcArray);\n\t\t\t});\n\t\t}\n\n\t\tresolver.resolve(promise);\n\t}\n\n\tpluginInstance = {\n\t\tfactories: {\n\t\t\tmodule: moduleFactory,\n\t\t\tcreate: instanceFactory,\n\t\t\tliteral: literalFactory,\n\t\t\tprototype: protoFactory,\n\t\t\tclone: cloneFactory,\n\t\t\tcompose: composeFactory,\n\t\t\tinvoker: invokerFactory\n\t\t},\n\t\tfacets: {\n\t\t\t// properties facet.  Sets properties on components\n\t\t\t// after creation.\n\t\t\tproperties: {\n\t\t\t\tconfigure: propertiesFacet\n\t\t\t},\n\t\t\tmixin: {\n\t\t\t\tconfigure: mixinFacet\n\t\t\t},\n\t\t\t// init facet.  Invokes methods on components during\n\t\t\t// the \"init\" stage.\n\t\t\tinit: {\n\t\t\t\tinitialize: invokerFacet\n\t\t\t},\n\t\t\t// ready facet.  Invokes methods on components during\n\t\t\t// the \"ready\" stage.\n\t\t\tready: {\n\t\t\t\tready: invokerFacet\n\t\t\t},\n\t\t\t// destroy facet.  Registers methods to be invoked\n\t\t\t// on components when the enclosing context is destroyed\n\t\t\tdestroy: {\n\t\t\t\tdestroy: invokerFacet\n\t\t\t}\n\t\t}\n\t};\n\n\t// \"introduce\" is deprecated, but preserved here for now.\n\tpluginInstance.facets.introduce = pluginInstance.facets.mixin;\n\n\treturn function(/* options */) {\n\t\treturn pluginInstance;\n\t};\n});\n})(typeof define == 'function'\n\t? define\n\t: function(factory) { module.exports = factory(require); }\n);\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/lib/functional.js":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * functional\n * Helper library for working with pure functions in wire and wire plugins\n *\n * NOTE: This lib assumes Function.prototype.bind is available\n *\n * wire is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\n(function (define) { 'use strict';\ndefine(function (require) {\n\n\tvar asap, slice;\n\n\tasap = require('./asap');\n\tslice = [].slice;\n\n\t/**\n\t * Create a partial function\n\t * @param f {Function}\n\t * @param [args] {*} additional arguments will be bound to the returned partial\n\t * @return {Function}\n\t */\n\tfunction partial(f, args/*...*/) {\n\t\t// Optimization: return f if no args provided\n\t\tif(arguments.length == 1) {\n\t\t\treturn f;\n\t\t}\n\n\t\targs = slice.call(arguments, 1);\n\n\t\treturn function() {\n\t\t\treturn f.apply(this, args.concat(slice.call(arguments)));\n\t\t};\n\t}\n\n\t/**\n\t * Promise-aware function composition. If any function in\n\t * the composition returns a promise, the entire composition\n\t * will be lifted to return a promise.\n\t * @param funcs {Array} array of functions to compose\n\t * @return {Function} composed function\n\t */\n\tfunction compose(funcs) {\n\t\tvar first;\n\n\t\tfirst = funcs[0];\n\t\tfuncs = funcs.slice(1);\n\n\t\treturn function composed() {\n\t\t\tvar context = this;\n\t\t\treturn funcs.reduce(function(result, f) {\n\t\t\t\treturn asap(result, function(result) {\n\t\t\t\t\treturn f.call(context, result);\n\t\t\t\t});\n\t\t\t}, first.apply(this, arguments));\n\t\t};\n\t}\n\n\treturn {\n\t\tcompose: compose,\n\t\tpartial: partial\n\t};\n\n});\n})(typeof define == 'function'\n\t// AMD\n\t? define\n\t// CommonJS\n\t: function(factory) { module.exports = factory(require); }\n);\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/lib/asap.js":"/** @license MIT License (c) copyright 2011-2013 original author or authors */\n\n/**\n * @author Brian Cavalier\n * @author John Hann\n */\n\n(function (define) { 'use strict';\ndefine(function (require) {\n\n\tvar when = require('when');\n\n\t/**\n\t * WARNING: This is not the function you're looking for. You\n\t * probably want when().\n\t * This function *conditionally* executes onFulfill synchronously\n\t * if promiseOrValue is a non-promise, or calls when(promiseOrValue,\n\t * onFulfill, onReject) otherwise.\n\t * @return {Promise|*} returns a promise if promiseOrValue is\n\t *  a promise, or the return value of calling onFulfill\n\t *  synchronously otherwise.\n\t */\n\treturn function asap(promiseOrValue, onFulfill, onReject) {\n\t\treturn when.isPromiseLike(promiseOrValue)\n\t\t\t? when(promiseOrValue, onFulfill, onReject)\n\t\t\t: onFulfill(promiseOrValue);\n\t};\n\n});\n})(typeof define == 'function' && define.amd ? define : function(factory) { module.exports = factory(require); });\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/lib/pipeline.js":"/** @license MIT License (c) copyright 2010-2013 original author or authors */\n\n/**\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @author: Brian Cavalier\n * @author: John Hann\n */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar when, compose, pipelineSplitRx;\n\n\twhen = require('when');\n\tcompose = require('./functional').compose;\n\tpipelineSplitRx = /\\s*\\|\\s*/;\n\n\treturn function pipeline(proxy, composeString, wire) {\n\n\t\tvar bindSpecs, resolveRef, getProxy;\n\n\t\tif(typeof composeString != 'string') {\n\t\t\treturn wire(composeString).then(function(func) {\n\t\t\t\treturn createProxyInvoker(proxy, func);\n\t\t\t});\n\t\t}\n\n\t\tbindSpecs = composeString.split(pipelineSplitRx);\n\t\tresolveRef = wire.resolveRef;\n\t\tgetProxy = wire.getProxy;\n\n\t\tfunction createProxyInvoker(proxy, method) {\n\t\t\treturn function() {\n\t\t\t\treturn proxy.invoke(method, arguments);\n\t\t\t};\n\t\t}\n\n\t\tfunction createBound(proxy, bindSpec) {\n\t\t\tvar target, method;\n\n\t\t\ttarget = bindSpec.split('.');\n\n\t\t\tif(target.length > 2) {\n\t\t\t\tthrow new Error('Only 1 \".\" is allowed in refs: ' + bindSpec);\n\t\t\t}\n\n\t\t\tif(target.length > 1) {\n\t\t\t\tmethod = target[1];\n\t\t\t\ttarget = target[0];\n\t\t\t\treturn when(getProxy(target), function(proxy) {\n\t\t\t\t\treturn createProxyInvoker(proxy, method);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tif(proxy && typeof proxy.get(bindSpec) == 'function') {\n\t\t\t\t\treturn createProxyInvoker(proxy, bindSpec);\n\t\t\t\t} else {\n\t\t\t\t\treturn resolveRef(bindSpec);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\t// First, resolve each transform function, stuffing it into an array\n\t\t// The result of this reduce will an array of concrete functions\n\t\t// Then add the final context[method] to the array of funcs and\n\t\t// return the composition.\n\t\treturn when.reduce(bindSpecs, function(funcs, bindSpec) {\n\t\t\treturn when(createBound(proxy, bindSpec), function(func) {\n\t\t\t\tfuncs.push(func);\n\t\t\t\treturn funcs;\n\t\t\t});\n\t\t}, []).then(\n\t\t\tfunction(funcs) {\n\t\t\t\tvar context = proxy && proxy.target;\n\t\t\t\treturn (funcs.length == 1 ? funcs[0] : compose(funcs)).bind(context);\n\t\t\t}\n\t\t);\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/lib/invoker.js":"(function(define) {\ndefine(function() {\n\n\treturn function(methodName, args) {\n\t\treturn function(target) {\n\t\t\treturn target[methodName].apply(target, args);\n\t\t};\n\t};\n\n});\n})(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); });","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/lib/graph/trackInflightRefs.js":"/**\n * trackInflightRefs\n * @author: brian@hovercraftstudios.com\n */\n(function(define) {\ndefine(function(require) {\n\n\tvar timeout, findStronglyConnected, formatCycles, refCycleCheckTimeout;\n\n\ttimeout = require('when/timeout');\n\tfindStronglyConnected = require('./tarjan');\n\tformatCycles = require('./formatCycles');\n\n\trefCycleCheckTimeout = 5000;\n\n\t/**\n\t * Advice to track inflight refs using a directed graph\n\t * @param {DirectedGraph} graph\n\t * @param {Resolver} resolver\n\t * @param {number} cycleTimeout how long to wait for any one reference to resolve\n\t *  before performing cycle detection. This basically debounces cycle detection\n\t */\n\treturn function trackInflightRefs(graph, resolver, cycleTimeout) {\n\t\tvar create = resolver.create;\n\n\t\tif(typeof cycleTimeout != 'number') {\n\t\t\tcycleTimeout = refCycleCheckTimeout;\n\t\t}\n\n\t\tresolver.create = function() {\n\t\t\tvar ref, resolve;\n\n\t\t\tref = create.apply(resolver, arguments);\n\n\t\t\tresolve = ref.resolve;\n\t\t\tref.resolve = function() {\n\t\t\t\tvar inflight = resolve.apply(ref, arguments);\n\t\t\t\treturn trackInflightRef(graph, cycleTimeout, inflight, ref.name, arguments[1]);\n\t\t\t};\n\n\t\t\treturn ref;\n\t\t};\n\n\t\treturn resolver;\n\t};\n\n\n\t/**\n\t * Add this reference to the reference graph, and setup a timeout that will fire if the refPromise\n\t * has not resolved in a reasonable amount.  If the timeout fires, check the current graph for cycles\n\t * and fail wiring if we find any.\n\t * @param {DirectedGraph} refGraph graph to use to track cycles\n\t * @param {number} cycleTimeout how long to wait for any one reference to resolve\n\t *  before performing cycle detection. This basically debounces cycle detection\n\t * @param {object} refPromise promise for reference resolution\n\t * @param {string} refName reference being resolved\n\t * @param {string} onBehalfOf some indication of another component on whose behalf this\n\t *  reference is being resolved.  Used to build a reference graph and detect cycles\n\t * @return {object} promise equivalent to refPromise but that may be rejected if cycles are detected\n\t */\n\tfunction trackInflightRef(refGraph, cycleTimeout, refPromise, refName, onBehalfOf) {\n\n\t\tonBehalfOf = onBehalfOf||'?';\n\t\trefGraph.addEdge(onBehalfOf, refName);\n\n\t\treturn timeout(cycleTimeout, refPromise).then(\n\t\t\tfunction(resolved) {\n\t\t\t\trefGraph.removeEdge(onBehalfOf, refName);\n\t\t\t\treturn resolved;\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\tvar stronglyConnected, cycles;\n\n\t\t\t\tstronglyConnected = findStronglyConnected(refGraph);\n\t\t\t\tcycles = stronglyConnected.filter(function(node) {\n\t\t\t\t\treturn node.length > 1;\n\t\t\t\t});\n\n\t\t\t\tif(cycles.length) {\n\t\t\t\t\t// Cycles detected\n\t\t\t\t\tthrow new Error('Possible circular refs:\\n'\n\t\t\t\t\t\t+ formatCycles(cycles));\n\t\t\t\t}\n\n\t\t\t\treturn refPromise;\n\t\t\t}\n\t\t);\n\t}\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/aop.js":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * wire/aop plugin\n * Provides AOP for components created via wire, including Decorators,\n * Introductions (mixins), and Pointcut-based Aspect Weaving.\n *\n * wire is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar meld, when, sequence, connection, adviceTypes, adviceStep, undef;\n\n\tmeld = require('meld');\n\twhen = require('when');\n\tsequence = require('when/sequence');\n\tconnection = require('./lib/connection');\n\n\t// \"after\" is not included in these standard advice types because\n\t// it is created as promise-aware advice.\n\tadviceTypes = ['before', 'around', 'afterReturning', 'afterThrowing'];\n\tadviceStep = 'connect:before';\n\n    //\n    // Decoration\n    //\n\n    function applyDecorator(target, Decorator, args) {\n        args = args ? [target].concat(args) : [target];\n\n        Decorator.apply(null, args);\n    }\n\n    function makeDecorator(decorator, args, wire) {\n\t\treturn function(target) {\n\t\t\tfunction apply(Decorator) {\n\t\t\t\treturn args\n\t\t\t\t\t? when(wire(args), function (resolvedArgs) {\n\t\t\t\t\tapplyDecorator(target, Decorator, resolvedArgs);\n\t\t\t\t})\n\t\t\t\t\t: applyDecorator(target, Decorator);\n\t\t\t}\n\n\t\t\treturn when(wire.resolveRef(decorator), apply);\n\t\t};\n    }\n\n    function decorateFacet(resolver, facet, wire) {\n        var target, options, tasks;\n\n        target = facet.target;\n        options = facet.options;\n        tasks = [];\n\n        for(var decoratorRefName in options) {\n            tasks.push(makeDecorator(decoratorRefName, options[decoratorRefName], wire));\n        }\n\n\t\tresolver.resolve(sequence(tasks, target));\n    }\n\n\t//\n\t// Simple advice\n\t//\n\n\tfunction addSingleAdvice(addAdviceFunc, proxy, advice, options, wire, advices) {\n\n\t\tfunction handleAopConnection(srcProxy, srcMethod, adviceHandler) {\n\t\t\tcheckAdvisable(srcProxy.target, srcMethod);\n\t\t\tadvices.push(addAdviceFunc(srcProxy, srcMethod, adviceHandler));\n\t\t}\n\n\t\treturn connection.parse(proxy, advice, options, wire, handleAopConnection);\n\t}\n\n\tfunction checkAdvisable(source, method) {\n\t\tif (!(typeof method == 'function' || typeof source[method] == 'function')) {\n\t\t\tthrow new TypeError('Cannot add advice to non-method: ' + method);\n\t\t}\n\t}\n\n\tfunction makeSingleAdviceAdd(adviceType) {\n\t\treturn function (srcProxy, sourceMethod, advice) {\n\t\t\tvar aspect = {};\n\t\t\taspect[adviceType] = advice;\n\t\t\treturn srcProxy.advise(sourceMethod, aspect);\n\t\t};\n\t}\n\n\tfunction addAfterFulfillingAdvice(srcProxy, sourceMethod, advice) {\n\t\treturn srcProxy.advise(sourceMethod, {\n\t\t\tafterReturning: function(promise) {\n\t\t\t\treturn when(promise, advice);\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction addAfterRejectingAdvice(srcProxy, sourceMethod, advice) {\n\t\treturn srcProxy.advise(sourceMethod, {\n\t\t\tafterReturning: function(promise) {\n\t\t\t\treturn when(promise, null, advice);\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction addAfterPromiseAdvice(srcProxy, sourceMethod, advice) {\n\t\treturn srcProxy.advise(sourceMethod, {\n\t\t\tafter: function(promise) {\n\t\t\t\treturn when(promise, advice, advice);\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction makeAdviceFacet(advices, addAdviceFunc) {\n\t\treturn function(resolver, facet, wire) {\n\t\t\tvar advice, target, advicesToAdd, promises;\n\n\t\t\ttarget = facet;\n\t\t\tadvicesToAdd = facet.options;\n\t\t\tpromises = [];\n\n\t\t\tfor(advice in advicesToAdd) {\n\t\t\t\tpromises.push(addSingleAdvice(addAdviceFunc,\n\t\t\t\t\ttarget, advice, advicesToAdd[advice], wire, advices));\n\t\t\t}\n\n\t\t\tresolver.resolve(when.all(promises));\n\t\t};\n\t}\n\n    //\n    // Aspect Weaving\n    //\n\n    function applyAspectCombined(targetProxy, aspect, wire, aspects) {\n        return when(wire.resolveRef(aspect), function (aspect) {\n            var pointcut = aspect.pointcut;\n\n            if (pointcut) {\n                aspects.push(targetProxy.advise(pointcut, aspect));\n            }\n\n            return targetProxy;\n        });\n    }\n\n    function applyAspectSeparate(targetProxy, aspect, wire, aspects) {\n        var pointcut, advice;\n\n        pointcut = aspect.pointcut;\n        advice = aspect.advice;\n\n        function applyAdvice(pointcut) {\n            return when(wire.resolveRef(advice), function (aspect) {\n                aspects.push(targetProxy.advise(pointcut, aspect));\n                return targetProxy;\n            });\n        }\n\n        return typeof pointcut === 'string'\n            ? when(wire.resolveRef(pointcut, applyAdvice))\n            : applyAdvice(pointcut);\n    }\n\n    function weave(proxy, wire, options, wovenAspects) {\n\t\t// TODO: Refactor weaving to use proxy.invoke\n\n        var target, path, aspects, applyAdvice;\n\n        aspects = options.aspects;\n        path = proxy.path;\n\n        if (path === undef) {\n            return;\n        }\n\n        target = proxy.target;\n        applyAdvice = applyAspectCombined;\n\n        // Reduce will preserve order of aspects being applied\n        return when.reduce(aspects, function(proxy, aspect) {\n            var aspectPath;\n\n            if (aspect.advice) {\n                aspectPath = aspect.advice;\n                applyAdvice = applyAspectSeparate;\n            } else {\n                aspectPath = aspect;\n            }\n\n            return typeof aspectPath === 'string' && aspectPath !== path\n                ? applyAdvice(proxy, aspect, wire, wovenAspects)\n                : proxy;\n\n        }, proxy);\n    }\n\n\t/**\n\t * Creates wire/aop plugin instances.\n\t *\n\t * @param options {Object} options passed to the plugin\n\t */\n    return function(options) {\n\n\t\tvar plugin, aspects, makeAdvice;\n\n\t\taspects = [];\n\t\tmakeAdvice = makeAdviceFacet.bind(null, aspects);\n\n\t\tplugin = {\n\t\t\tcontext: {\n\t\t\t\tdestroy: function(resolver) {\n\t\t\t\t\tconnection.removeAll(aspects);\n\t\t\t\t\tresolver.resolve();\n\t\t\t\t}\n\t\t\t},\n\t\t\tfacets: {\n\t\t\t\tdecorate:       makeFacet('configure:after', decorateFacet),\n\t\t\t\tafterFulfilling: makeFacet(adviceStep, makeAdvice(addAfterFulfillingAdvice)),\n\t\t\t\tafterRejecting:  makeFacet(adviceStep, makeAdvice(addAfterRejectingAdvice)),\n\t\t\t\tafter: makeFacet(adviceStep, makeAdvice(addAfterPromiseAdvice))\n\t\t\t}\n\t\t};\n\n\t\tif(options.aspects) {\n\t\t\tplugin.create = function(resolver, proxy, wire) {\n\t\t\t\tvar woven = weave(proxy, wire, options, aspects);\n\t\t\t\tresolver.resolve(woven);\n\t\t\t};\n\t\t}\n\n\t\t// Add all regular single advice facets\n\t\tadviceTypes.forEach(function(adviceType) {\n\t\t\tplugin.facets[adviceType] = makeFacet(adviceStep,\n\t\t\t\tmakeAdvice(makeSingleAdviceAdd(adviceType)));\n\t\t});\n\n\t\treturn plugin;\n\n\t\tfunction makeFacet(step, callback) {\n\t\t\tvar facet = {};\n\n\t\t\tfacet[step] = function(resolver, proxy, wire) {\n\t\t\t\tcallback(resolver, proxy, wire);\n\t\t\t};\n\n\t\t\treturn facet;\n\t\t}\n\n\t};\n});\n}(typeof define == 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/lib/connection.js":"/** @license MIT License (c) copyright 2011-2013 original author or authors */\n\n/**\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * Helper module that parses incoming and outgoing method-call-based\n * connection specs. This module is used by wire plugins to parse connections.\n *\n * Incoming connection forms:\n *\n * 'srcComponent.triggerMethod': 'method'\n * 'srcComponent.triggerMethod': 'transforms | method'\n * srcComponent: {\n *   triggerMethod1: 'method',\n *   triggerMethod2: 'transforms | method',\n *   ...\n * }\n *\n * Outgoing connection forms:\n *\n * eventName: 'destComponent.method'\n * eventName: 'transforms | destComponent.method'\n * eventName: {\n *   destComponent1: 'method',\n *   destComponent2: 'transforms | method',\n *   ...\n * }\n *\n * @author Brian Cavalier\n * @author John Hann\n */\n\n(function(define){ 'use strict';\ndefine(function(require) {\n\n\tvar when, array, pipeline;\n\n\twhen = require('when');\n\tarray = require('./array');\n\tpipeline = require('./pipeline');\n\n\treturn {\n\t\tparse: parse,\n\t\tparseIncoming: parseIncoming,\n\t\tparseOutgoing: parseOutgoing,\n\t\tremoveAll: removeAll\n\t};\n\n\tfunction removeAll(connections) {\n\t\tconnections.forEach(function(c) {\n\t\t\tc.remove();\n\t\t});\n\t}\n\n\t/**\n\t * Determines if the connections are incoming or outgoing, and invokes parseIncoming\n\t * or parseOutgoing accordingly.\n\t * @param proxy\n\t * @param connect\n\t * @param options\n\t * @param wire {Function} wire function to use to wire, resolve references, and get proxies\n\t * @param createConnection {Function} callback that will do the work of creating\n\t *  the actual connection from the parsed information\n\t * @return {Promise} promise that resolves when connections have been created, or\n\t *  rejects if an error occurs.\n\t */\n\tfunction parse(proxy, connect, options, wire, createConnection) {\n\t\tvar source, eventName;\n\n\t\t// First, determine the direction of the connection(s)\n\t\t// If ref is a method on target, connect it to another object's method, i.e. calling a method on target\n\t\t// causes a method on the other object to be called.\n\t\t// If ref is a reference to another object, connect that object's method to a method on target, i.e.\n\t\t// calling a method on the other object causes a method on target to be called.\n\n\t\tsource = connect.split('.');\n\t\teventName = source[1];\n\t\tsource = source[0];\n\n\t\treturn when(wire.getProxy(source),\n\t\t\tfunction(srcProxy) {\n\t\t\t\treturn parseIncoming(srcProxy, eventName, proxy, connect, options, wire, createConnection);\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\treturn parseOutgoing(proxy, connect, options, wire, createConnection);\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * Parse incoming connections and call createConnection to do the work of\n\t * creating the connection.\n\t *\n\t * @param source\n\t * @param eventName\n\t * @param targetProxy\n\t * @param connect\n\t * @param options\n\t * @param wire {Function} wire function to use to wire, resolve references, and get proxies\n\t * @param createConnection {Function} callback that will do the work of creating\n\t *  the actual connection from the parsed information\n\t * @return {Promise} promise that resolves when connections have been created, or\n\t *  rejects if an error occurs.\n\t */\n\tfunction parseIncoming(source, eventName, targetProxy, connect, options, wire, createConnection) {\n\t\tvar promise, methodNames;\n\n\t\tif(eventName) {\n\t\t\t// 'component.eventName': 'methodName'\n\t\t\t// 'component.eventName': 'transform | methodName'\n\n\t\t\tmethodNames = Array.isArray(options) ? options : [ options ];\n\n\t\t\tpromise = when.map(methodNames, function(methodName) {\n\t\t\t\treturn pipeline(targetProxy, methodName, wire).then(\n\t\t\t\t\tfunction(func) {\n\t\t\t\t\t\tvar invoker = proxyInvoker(targetProxy, func);\n\n\t\t\t\t\t\treturn createConnection(source, eventName, invoker);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t});\n\n\t\t} else {\n\t\t\t// componentName: {\n\t\t\t//   eventName: 'methodName'\n\t\t\t//   eventName: 'transform | methodName'\n\t\t\t// }\n\n\t\t\tpromise = wire.getProxy(connect).then(function(srcProxy) {\n\t\t\t\tvar name, promises;\n\n\t\t\t\tfunction createConnectionFactory(srcProxy, name, targetProxy) {\n\t\t\t\t\treturn function(func) {\n\t\t\t\t\t\tvar invoker = proxyInvoker(targetProxy, func);\n\n\t\t\t\t\t\treturn createConnection(srcProxy, name, invoker);\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tpromises = [];\n\t\t\t\tfor(name in options) {\n\t\t\t\t\tvar connectionFactory, composed;\n\n\t\t\t\t\tconnectionFactory = createConnectionFactory(srcProxy, name, targetProxy);\n\t\t\t\t\tcomposed = pipeline(targetProxy, options[name], wire);\n\n\t\t\t\t\tpromises.push(composed.then(connectionFactory));\n\t\t\t\t}\n\n\t\t\t\treturn when.all(promises);\n\t\t\t});\n\t\t}\n\n\t\treturn promise;\n\n\t}\n\n\t/**\n\t * Parse outgoing connections and call createConnection to do the actual work of\n\t * creating the connection.  Supported forms:\n\t *\n\t * @param proxy\n\t * @param connect\n\t * @param options\n\t * @param wire {Function} wire function to use to wire, resolve references, and get proxies\n\t * @param createConnection {Function} callback that will do the work of creating\n\t *  the actual connection from the parsed information\n\t * @return {Promise} promise that resolves when connections have been created, or\n\t *  rejects if an error occurs.\n\t */\n\tfunction parseOutgoing(proxy, connect, options, wire, createConnection) {\n\t\treturn createOutgoing(proxy, connect, proxy, options, wire, createConnection);\n\t}\n\n\tfunction createOutgoing(sourceProxy, eventName, targetProxy, options, wire, createConnection) {\n\t\tvar promise, promises, resolveAndConnectOneOutgoing, name;\n\n\t\tfunction connectOneOutgoing(targetProxy, targetMethodSpec) {\n\t\t\treturn when(pipeline(targetProxy, targetMethodSpec, wire),\n\t\t\t\tfunction(func) {\n\t\t\t\t\tvar invoker = proxyInvoker(targetProxy, func);\n\t\t\t\t\treturn createConnection(sourceProxy, eventName, invoker);\n\t\t\t\t});\n\n\t\t}\n\n\t\tif(typeof options == 'string') {\n\t\t\t// eventName: 'transform | componentName.methodName'\n\t\t\tpromise = connectOneOutgoing(targetProxy, options);\n\n\t\t} else {\n\t\t\tpromises = [];\n\n\t\t\tresolveAndConnectOneOutgoing = function(targetRef, targetMethodSpec) {\n\t\t\t\treturn when(wire.getProxy(targetRef), function(targetProxy) {\n\t\t\t\t\treturn connectOneOutgoing(targetProxy, targetMethodSpec);\n\t\t\t\t});\n\t\t\t};\n\n\t\t\tif (Array.isArray(options)) {\n\t\t\t\t// eventName: [ 'methodName1', 'methodName2' ]\n\t\t\t\tfor (var i = 0, t = options.length; i < t; i++) {\n\t\t\t\t\tpromises.push(connectOneOutgoing(targetProxy, options[i]));\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t// eventName: {\n\t\t\t\t//   componentName: 'methodName'\n\t\t\t\t//   componentName: 'transform | methodName'\n\t\t\t\t// }\n\t\t\t\tfor(name in options) {\n\t\t\t\t\tpromises.push(resolveAndConnectOneOutgoing(name, options[name]));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpromise = when.all(promises);\n\t\t}\n\n\t\treturn promise;\n\t}\n\n\tfunction proxyInvoker(proxy, method) {\n\t\treturn function() {\n\t\t\treturn proxy.invoke(method, arguments);\n\t\t};\n\t}\n\n});\n}(typeof define == 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/connect.js":"/** @license MIT License (c) copyright 2011-2013 original author or authors */\n\n/**\n * wire/connect plugin\n * wire plugin that can connect synthetic events (method calls) on one\n * component to methods of another object.  For example, connecting a\n * view's onClick event (method) to a controller's _handleViewClick method:\n *\n * view: {\n *     create: 'myView',\n *     ...\n * },\n * controller: {\n *     create: 'myController',\n *     connect: {\n *         'view.onClick': '_handleViewClick'\n *     }\n * }\n *\n * It also supports arbitrary transforms on the data that flows over the\n * connection.\n *\n * transformer: {\n *     module: 'myTransformFunction'\n * },\n * view: {\n *     create: 'myView',\n *     ...\n * },\n * controller: {\n *     create: 'myController',\n *     connect: {\n *         'view.onClick': 'transformer | _handleViewClick'\n *     }\n * }\n *\n * wire is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @author Brian Cavalier\n * @author John Hann\n */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar all, connection;\n\n\tall = require('when').all;\n\tconnection = require('./lib/connection');\n\n\treturn function connectPlugin(/* options */) {\n\n\t\tvar connections = [];\n\n\t\tfunction makeConnection(sourceProxy, methodName, handler) {\n\t\t\tconnections.push(sourceProxy.advise(methodName, { on: handler }));\n\t\t}\n\n\t\tfunction connectFacet(wire, facet) {\n\t\t\tvar promises, connects;\n\n\t\t\tconnects = facet.options;\n\t\t\tpromises = Object.keys(connects).map(function(key) {\n\t\t\t\treturn connection.parse(\n\t\t\t\t\tfacet, key, connects[key], wire, makeConnection);\n\t\t\t});\n\n\t\t\treturn all(promises);\n\t\t}\n\n\t\treturn {\n\t\t\tcontext: {\n\t\t\t\tdestroy: function(resolver) {\n\t\t\t\t\tconnection.removeAll(connections);\n\t\t\t\t\tresolver.resolve();\n\t\t\t\t}\n\t\t\t},\n\t\t\tfacets: {\n\t\t\t\t// A facet named \"connect\" that runs during the connect\n\t\t\t\t// lifecycle phase\n\t\t\t\tconnect: {\n\t\t\t\t\tconnect: function(resolver, facet, wire) {\n\t\t\t\t\t\tresolver.resolve(connectFacet(wire, facet));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n    };\n});\n}(typeof define == 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/debug.js":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/*jshint sub:true*/\n/*global Node:true*/\n\n/**\n * debug\n * wire plugin that logs timing and debug information about wiring context and object\n * lifecycle events (e.g. creation, properties set, initialized, etc.).\n *\n * wire is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * Usage:\n * {\n *     module: 'wire/debug',\n *\n *     // verbose (Optional)\n *     // If set to true, even more (a LOT) info will be output.\n *     // Default is false if not specified.\n *     verbose: false,\n *\n *     // timeout (Optional)\n *     // Milliseconds to wait for wiring to finish before reporting\n *     // failed components.  There may be failures caused by 3rd party\n *     // wire plugins and components that wire.js cannot detect.  This\n *     // provides a last ditch way to try to report those failures.\n *     // Default is 5000ms (5 seconds)\n *     timeout: 5000,\n *\n *     // filter (Optional)\n *     // String or RegExp to match against a component's name.  Only\n *     // components whose path matches will be reported in the debug\n *     // diagnostic output.\n *     // All components will still be tracked for failures.\n *     // This can be useful in reducing the amount of diagnostic output and\n *     // focusing it on specific components.\n *     // Defaults to matching all components\n *     // Examples:\n *     //   filter: \".*View\"\n *     //   filter: /.*View/\n *     //   filter: \"[fF]oo[bB]ar\"\n *     filter: \".*\"\n *\n *     // trace (Optional)\n *     // Enables application component tracing that will log information about component\n *     // method calls while your application runs.  This provides a powerful way to watch\n *     // and debug your application as it runs.\n *     // To enable full tracing, which is a LOT of information:\n *     trace: true\n *     // Or, specify options to enable more focused tracing:\n *     trace: {\n *          // filter (Optional)\n *          // Similar to above, can be string pattern or RegExp\n *          // If not specified, the general debug filter is used (see above)\n *          filter: \".*View\",\n *\n *          // pointcut (Optional)\n *          // Matches *method names*.  Can be used with or without specifying filter\n *          // When filter is not specified, this will match methods across all components.\n *          // For example, if all your components name their event emitters \"on<Event>\", e.g. \"onClick\"\n *          // you could trace all your event emitters:\n *          // Default: \"^[^_]\" (all methods not starting with '_')\n *          pointcut: \"on.*\",\n *\n *          // step (Optional)\n *          // At what step in the wiring process should tracing start.  This can be helpful\n *          // if you need to trace a component during wiring.\n *          // Values: 'create', 'configure', 'initialize', 'ready', 'destroy'\n *          // NOTE: This defines when tracing *begins*.  For example, if this is set to\n *          // 'configure' (the default), anything that happens to components during and\n *          // after the configure step, until that component is destroyed, will be traced.\n *          // Default: 'configure'\n *          step: 'configure'\n *     }\n * }\n */\n(function(global, define) {\ndefine(function(require) {\n\tvar meld, timer, defaultTimeout, logger, createTracer, ownProp;\n\n\tmeld = require('meld');\n\n\tfunction noop() {}\n\n\townProp = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);\n\n\t// Setup console for node, sane browsers, or IE\n\tlogger = typeof console != 'undefined'\n\t\t? console\n\t\t: global['console'] || { log:noop, error:noop };\n\n\t// TODO: Consider using stacktrace.js\n\t// https://github.com/eriwen/javascript-stacktrace\n\t// For now, quick and dirty, based on how stacktrace.js chooses the appropriate field\n\t// and log using console.error\n\tfunction logStack(e) {\n\t\tvar stack = e.stack || e.stacktrace;\n\t\tif(!stack) {\n\t\t\t// If e.sourceURL and e.line are available, this is probably Safari, so\n\t\t\t// we can build a clickable source:line\n\t\t\t// Fallback to message if available\n\t\t\t// If all else fails, just use e itself\n\t\t\tstack = e.sourceURL && e.line\n\t\t\t\t? e.sourceURL + ':' + e.line\n\t\t\t\t: e.message || e;\n\t\t}\n\n\t\tlogger.error(stack);\n\t}\n\n\ttimer = createTimer();\n\n\t// If we don't see any wiring progress in this amount of time\n\t// since the last time we saw something happen, then we'll log\n\t// an error.\n\tdefaultTimeout = 5000;\n\n\t/**\n\t * Builds a string with timing info and a message for debug output\n\t *\n\t * @param text {String} message\n\t * @param contextTimer per-context timer information\n\t *\n\t * @returns A formatted string for output\n\t */\n\tfunction time(text, contextTimer) {\n\t\tvar all, timing;\n\n\t\tall = timer();\n\t\ttiming = \"(total: \" +\n\t\t\t\t (contextTimer\n\t\t\t\t\t ? all.total + \"ms, context: \" + contextTimer()\n\t\t\t\t\t : all)\n\t\t\t+ \"): \";\n\n\t\treturn \"DEBUG \" + timing + text;\n\t}\n\n\t/**\n\t * Creates a timer function that, when called, returns an object containing\n\t * the total elapsed time since the timer was created, and the split time\n\t * since the last time the timer was called.  All times in milliseconds\n\t *\n\t * @returns timer\n\t */\n\tfunction createTimer() {\n\t\tvar start, split;\n\n\t\tstart = new Date().getTime();\n\t\tsplit = start;\n\n\t\t/**\n\t\t * Returns the total elapsed time since this timer was created, and the\n\t\t * split time since this getTime was last called.\n\t\t *\n\t\t * @returns Object containing total and split times in milliseconds, plus a\n\t\t * toString() function that is useful in logging the time.\n\t\t */\n\t\treturn function getTime() {\n\t\t\tvar now, total, splitTime;\n\n\t\t\tnow = new Date().getTime();\n\t\t\ttotal = now - start;\n\t\t\tsplitTime = now - split;\n\t\t\tsplit = now;\n\n\t\t\treturn {\n\t\t\t\ttotal:total,\n\t\t\t\tsplit:splitTime,\n\t\t\t\ttoString:function () {\n\t\t\t\t\treturn '' + splitTime + 'ms / ' + total + 'ms';\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n\n\tfunction defaultFilter(path) {\n\t\treturn !!path;\n\t}\n\n\tfunction createPathFilter(filter) {\n\t\tif (!filter) {\n\t\t\treturn defaultFilter;\n\t\t}\n\n\t\tvar rx = filter.test ? filter : new RegExp(filter);\n\n\t\treturn function (path) {\n\t\t\treturn rx.test(path);\n\t\t};\n\n\t}\n\n\t/**\n\t * Returns true if it is a Node\n\t * Adapted from: http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object\n\t * @param it anything\n\t * @return true iff it is a Node\n\t */\n\tfunction isNode(it) {\n\t\treturn typeof Node === \"object\"\n\t\t\t? it instanceof Node\n\t\t\t: it && typeof it === \"object\" && typeof it.nodeType === \"number\" && typeof it.nodeName===\"string\";\n\t}\n\n\tfunction isObject(it) {\n\t\t// In IE7 tos.call(null) is '[object Object]'\n\t\t// so we need to check to see if 'it' is\n\t\t// even set\n\t\treturn it && Object.prototype.toString.call(it) == '[object Object]';\n\t}\n\n\t/**\n\t * Function that applies tracing AOP to components being wired\n\t * @function\n\t * @param options {Object} tracing options\n\t * @param plugin {Object} debug plugin instance to which to add tracing functionality\n\t */\n\tcreateTracer = (function() {\n\t\tvar depth, padding, defaultStep, defaultPointcut;\n\n\t\t/** Current trace depth */\n\t\tdepth = 0;\n\n\t\t/** Padding character for indenting traces */\n\t\tpadding =  '.';\n\n\t\t/** 2^8 padding = 128 */\n\t\tfor(var i=0; i<8; i++) {\n\t\t\tpadding += padding;\n\t\t}\n\n\t\t/** Default lifecycle step at which to begin tracing */\n\t\tdefaultStep = 'configure';\n\n\t\t/** Default pointcut query to match methods that will be traced */\n\t\tdefaultPointcut = /^[^_]/;\n\n\t\tfunction logAfter(context, tag, start, val) {\n\t\t\tconsole.log(context + tag + (new Date().getTime() - start.getTime()) + 'ms): ', val);\n\t\t}\n\n\t\t/**\n\t\t * Creates an aspect to be applied to components that are being traced\n\t\t * @param path {String} component path\n\t\t */\n\t\tfunction createTraceAspect(path) {\n\t\t\treturn {\n\t\t\t\taround:function (joinpoint) {\n\t\t\t\t\tvar val, context, start, indent;\n\n\t\t\t\t\t// Setup current indent level\n\t\t\t\t\tindent = padding.substr(0, depth);\n\t\t\t\t\t// Form full path to invoked method\n\t\t\t\t\tcontext = indent + 'DEBUG: ' + path + '.' + joinpoint.method;\n\n\t\t\t\t\t// Increase the depth before proceeding so that nested traces will be indented\n\t\t\t\t\t++depth;\n\n\t\t\t\t\tlogger.log(context, joinpoint.args);\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tstart = new Date();\n\t\t\t\t\t\tval = joinpoint.proceed();\n\n\t\t\t\t\t\tlogAfter(context, ' RETURN (', start, val);\n\n\t\t\t\t\t\t// return result\n\t\t\t\t\t\treturn val;\n\n\t\t\t\t\t} catch (e) {\n\n\t\t\t\t\t\t// rethrow\n\t\t\t\t\t\tlogAfter(context, ' THROW (', start, e ? e.toString() : e);\n\n\t\t\t\t\t\tthrow e;\n\n\t\t\t\t\t} finally {\n\t\t\t\t\t\t// And now decrease the depth after\n\t\t\t\t\t\t--depth;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t/**\n\t\t * Implementation of createTracer\n\t\t */\n\t\treturn function(options, plugin, filter) {\n\t\t\tvar trace, untrace, traceStep, traceFilter, tracePointcut, traceAspects;\n\n\t\t\ttraceFilter = options.trace.filter ? createPathFilter(options.trace.filter) : filter;\n\t\t\ttracePointcut = options.trace.pointcut || defaultPointcut;\n\t\t\ttraceStep = options.trace.step || defaultStep;\n\n\t\t\tfunction isTraceable(target, prop) {\n\t\t\t\treturn isObject(target) && typeof target[prop] === 'function'\n\t\t\t\t\t&& prop !== 'wire$plugin'\n\t\t\t\t\t&& tracePointcut.test(prop);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Trace pointcut query function that filters out wire plugins\n\t\t\t * @param target {Object} target object to query for methods to advise\n\t\t\t */\n\t\t\tfunction pointcut(target) {\n\t\t\t\tvar matches = [];\n\n\t\t\t\tif(isNode(target)) {\n\t\t\t\t\treturn matches;\n\t\t\t\t}\n\n\t\t\t\tfor (var p in target) {\n\t\t\t\t\t// Only match functions, exclude wire plugins, and then apply\n\t\t\t\t\t// the supplied tracePointcut regexp\n\t\t\t\t\tif (isTraceable(target, p)) {\n\t\t\t\t\t\tmatches.push(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn matches;\n\t\t\t}\n\n\t\t\ttraceAspects = [];\n\t\t\ttrace = function (path, target) {\n\t\t\t\tif (traceFilter(path)) {\n\t\t\t\t\t// Create the aspect, if the path matched\n\t\t\t\t\ttraceAspects.push(meld.add(target, pointcut, createTraceAspect(path)));\n\t\t\t\t}\n\t\t\t\t// trace intentionally does not resolve the promise\n\t\t\t\t// trace relies on the existing plugin method to resolve it\n\t\t\t};\n\n\t\t\tuntrace = function () {\n\t\t\t\tfor (var i = traceAspects.length-1; i >= 0; --i) {\n\t\t\t\t\ttraceAspects[i].remove();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Defend against changes to the plugin in future revs\n\t\t\tvar orig = plugin[traceStep] || function (promise) { promise.resolve(); };\n\n\t\t\t// Replace the plugin listener method with one that will call trace()\n\t\t\t// and add traceAspect\n\t\t\tplugin[traceStep] = function (promise, proxy, wire) {\n\t\t\t\ttrace(proxy.path, proxy.target);\n\t\t\t\torig(promise, proxy, wire);\n\t\t\t};\n\n\t\t\treturn { trace: trace, untrace: untrace };\n\t\t};\n\n\t})();\n\n\tfunction logSeparator() {\n\t\tlogger.log('---------------------------------------------------');\n\t}\n\n\treturn function wireDebug(options) {\n\n\t\tvar contextTimer, timeout, paths, count, tag,\n\t\t\tlogCreated, logDestroyed, checkPathsTimeout,\n\t\t\tverbose, filter, plugin, context, tracer;\n\n\t\tverbose = options.verbose;\n\t\tcontextTimer = createTimer();\n\n\t\tcount = 0;\n\t\ttag = \"WIRING\";\n\n\t\ttracer = { trace: noop, untrace: noop };\n\n\t\tfilter = createPathFilter(options.filter);\n\n\t\tfunction contextTime(msg) {\n\t\t\treturn time(msg, contextTimer);\n\t\t}\n\n\t\tlogger.log(contextTime(\"Context debug\"));\n\n\t\tcontext = {\n\t\t\tinitialize: function(resolver) {\n\t\t\t\tlogger.log(contextTime(\"Context init\"));\n\t\t\t\tresolver.resolve();\n\t\t\t},\n\t\t\tready: function(resolver) {\n\t\t\t\tcancelPathsTimeout();\n\t\t\t\tlogger.log(contextTime(\"Context ready\"));\n\t\t\t\tresolver.resolve();\n\t\t\t},\n\t\t\tdestroy: function(resolver) {\n\t\t\t\ttracer.untrace();\n\t\t\t\tlogger.log(contextTime(\"Context destroyed\"));\n\t\t\t\tresolver.resolve();\n\t\t\t},\n\t\t\terror: function(resolver, api, err) {\n\t\t\t\tcancelPathsTimeout();\n\t\t\t\tconsole.error(contextTime(\"Context ERROR: \") + err, err);\n\t\t\t\tlogStack(err);\n\t\t\t\tresolver.reject(err);\n\t\t\t}\n\t\t};\n\n\t\tfunction makeListener(step, verbose) {\n\t\t\treturn function (promise, proxy /*, wire */) {\n\t\t\t\tcancelPathsTimeout();\n\n\t\t\t\tvar path = proxy.path;\n\n\t\t\t\tif (paths[path]) {\n\t\t\t\t\tpaths[path].status = step;\n\t\t\t\t}\n\n\t\t\t\tif (verbose && filter(path)) {\n\t\t\t\t\tvar message = time(step + ' ' + (path || proxy.id || ''), contextTimer);\n\t\t\t\t\tif (proxy.target) {\n\t\t\t\t\t\tlogger.log(message, proxy.target, proxy.metadata);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogger.log(message, proxy);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(count) {\n\t\t\t\t\tcheckPathsTimeout = setTimeout(checkPaths, timeout);\n\t\t\t\t}\n\n\t\t\t\tpromise.resolve();\n\t\t\t};\n\t\t}\n\n\t\tpaths = {};\n\t\ttimeout = options.timeout || defaultTimeout;\n\t\tlogCreated = makeListener('created', verbose);\n\t\tlogDestroyed = makeListener('destroyed', true);\n\n\t\tfunction cancelPathsTimeout() {\n\t\t\tclearTimeout(checkPathsTimeout);\n\t\t\tcheckPathsTimeout = null;\n\t\t}\n\n\t\tfunction checkPaths() {\n\t\t\tif (!checkPathsTimeout) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar p, component, msg, ready, notReady;\n\n\t\t\tlogSeparator();\n\t\t\tif(count) {\n\t\t\t\tready = [];\n\t\t\t\tnotReady = [];\n\t\t\t\tlogger.error(tag + ': No progress in ' + timeout + 'ms, status:');\n\n\t\t\t\tfor (p in paths) {\n\t\t\t\t\tcomponent = paths[p];\n\t\t\t\t\tmsg = p + ': ' + component.status;\n\n\t\t\t\t\t(component.status == 'ready' ? ready : notReady).push(\n\t\t\t\t\t\t{ msg: msg, metadata: component.metadata }\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif(notReady.length > 0) {\n\t\t\t\t\tlogSeparator();\n\t\t\t\t\tlogger.log('Components that DID NOT finish wiring');\n\t\t\t\t\tfor(p = notReady.length-1; p >= 0; --p) {\n\t\t\t\t\t\tcomponent = notReady[p];\n\t\t\t\t\t\tlogger.error(component.msg, component.metadata);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(ready.length > 0) {\n\t\t\t\t\tlogSeparator();\n\t\t\t\t\tlogger.log('Components that finished wiring');\n\t\t\t\t\tfor(p = ready.length-1; p >= 0; --p) {\n\t\t\t\t\t\tcomponent = ready[p];\n\t\t\t\t\t\tlogger.log(component.msg, component.metadata);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlogger.error(tag + ': No components created after ' + timeout + 'ms');\n\t\t\t}\n\n\t\t\tlogSeparator();\n\t\t}\n\n\t\t/**\n\t\t * Adds a named constructor function property to the supplied component\n\t\t * so that the name shows up in debug inspectors.  Squelches all errors.\n\t\t */\n\t\tfunction makeConstructor(name, component) {\n\t\t\t/*jshint evil:true*/\n\t\t\tvar ctor;\n\t\t\ttry {\n\t\t\t\t// Generate a named function to use as the constructor\n\t\t\t\tname = name.replace(/^[^a-zA-Z$_]|[^a-zA-Z0-9$_]+/g, '_');\n\t\t\t\teval('ctor = function ' + name + ' () {}');\n\n\t\t\t\t// Be friendly and make configurable and writable just in case\n\t\t\t\t// some other library or application code tries to set constructor.\n\t\t\t\tObject.defineProperty(component, 'constructor', {\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: ctor\n\t\t\t\t});\n\n\t\t\t} catch(e) {\n\t\t\t\t// Oh well, ignore.\n\t\t\t}\n\t\t}\n\n\t\tplugin = {\n\t\t\tcontext: context,\n\t\t\tcreate:function (promise, proxy) {\n\t\t\t\tvar path, component;\n\n\t\t\t\tpath = proxy.path;\n\t\t\t\tcomponent = proxy.target;\n\n\t\t\t\tcount++;\n\t\t\t\tpaths[path || ('(unnamed-' + count + ')')] = {\n\t\t\t\t\tmetadata: proxy.metadata\n\t\t\t\t};\n\n\t\t\t\tif(component && typeof component == 'object'\n\t\t\t\t\t&& !ownProp(component, 'constructor')) {\n\t\t\t\t\tmakeConstructor(proxy.id, component);\n\t\t\t\t}\n\n\t\t\t\tlogCreated(promise, proxy);\n\t\t\t},\n\t\t\tconfigure:  makeListener('configured', verbose),\n\t\t\tinitialize: makeListener('initialized', verbose),\n\t\t\tready:      makeListener('ready', true),\n\t\t\tdestroy:    function(promise, proxy) {\n\t\t\t\t// stop tracking destroyed components, since we don't\n\t\t\t\t// care anymore\n\t\t\t\tdelete paths[proxy.path];\n\t\t\t\tcount--;\n\t\t\t\ttag = \"DESTROY\";\n\n\t\t\t\tlogDestroyed(promise, proxy);\n\t\t\t}\n\t\t};\n\n\t\tif (options.trace) {\n\t\t\ttracer = createTracer(options, plugin, filter);\n\t\t}\n\n\t\tcheckPathsTimeout = setTimeout(checkPaths, timeout);\n\n\t\treturn plugin;\n\t};\n\n});\n})(this, typeof define == 'function' && define.amd\n\t? define : function(factory) { module.exports = factory(require); }\n);\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/dom.js":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * wire/dom plugin\n * wire plugin that provides a resource resolver for dom nodes, by id, in the\n * current page.  This allows easy wiring of page-specific dom references into\n * generic components that may be page-independent, i.e. makes it easier to write\n * components that can be used on multiple pages, but still require a reference\n * to one or more nodes on the page.\n *\n * wire is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\n\ndefine(['./lib/plugin-base/dom', './lib/dom/base'], function(createDomPlugin, base) {\n\n\treturn createDomPlugin({\n\t\taddClass: base.addClass,\n\t\tremoveClass: base.removeClass\n\t});\n\n});","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/domReady.js":"/** @license MIT License (c) copyright 2011-2013 original author or authors */\n\n/**\n * wire/domReady\n * A base wire/domReady module that plugins can use if they need domReady.  Simply\n * add 'wire/domReady' to your plugin module dependencies\n * (e.g. require(['wire/domReady', ...], function(domReady, ...) { ... })) and you're\n * set.\n *\n * wire is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * Returns a function that accepts a callback to be called when the DOM is ready.\n *\n * You can also use your AMD loader's paths config to map wire/domReady to whatever\n * domReady function you might want to use.  See documentation for your AMD loader\n * for specific instructions.  For curl.js and requirejs, it will be something like:\n *\n *  paths: {\n *      'wire/domReady': 'path/to/my/domReady'\n *  }\n *\n * @author Brian Cavalier\n * @author John Hann\n */\n\n(function(global) {\ndefine(['require'], function(req) {\n\n\t// Try require.ready first\n\treturn (global.require && global.require.ready) || function (cb) {\n\t\t// If it's not available, assume a domReady! plugin is available\n\t\treq(['domReady!'], function () {\n\t\t\t// Using domReady! as a plugin will automatically wait for domReady\n\t\t\t// so we can just call the callback.\n\t\t\tcb();\n\t\t});\n\t};\n\n});\n})(this);\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/on.js":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * wire/on plugin\n * wire plugin that provides an \"on\" facet to connect to dom events,\n * and includes support for delegation\n *\n * wire is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\n(function (define) {\ndefine(['./lib/plugin-base/on', './lib/dom/base'], function (createOnPlugin, base) {\n'use strict';\n\n\tvar contains;\n\n\t/**\n\t * Listens for dom events at the given node.  If a selector is provided,\n\t * events are filtered to only nodes matching the selector.  Note, however,\n\t * that children of the matching nodes can also fire events that bubble.\n\t * To determine the matching node, use the event object's selectorTarget\n\t * property instead of it's target property.\n\t * @param node {HTMLElement} element at which to listen\n\t * @param event {String} event name ('click', 'mouseenter')\n\t * @param handler {Function} handler function with the following signature: function (e) {}\n\t * @param [selector] {String} optional css query string to use to\n\t * @return {Function} removes the event handler\n\t */\n\tfunction on (node, event, handler /*, selector */) {\n\t\tvar selector = arguments[3];\n\n\t\tif (selector) {\n\t\t\thandler = filteringHandler(node, selector, handler);\n\t\t}\n\n\t\tnode.addEventListener(event, handler, false);\n\n\t\treturn function remove () {\n\t\t\tnode.removeEventListener(node, handler, false);\n\t\t};\n\t}\n\n\ton.wire$plugin = createOnPlugin({\n\t\ton: on\n\t});\n\n\tif (document && document.compareDocumentPosition) {\n\t\tcontains = function w3cContains (refNode, testNode) {\n\t\t\treturn (refNode.compareDocumentPosition(testNode) & 16) == 16;\n\t\t};\n\t}\n\telse {\n\t\tcontains = function oldContains (refNode, testNode) {\n\t\t\treturn refNode.contains(testNode);\n\t\t};\n\t}\n\n\treturn on;\n\n\t/**\n\t * This is a brute-force method of checking if an event target\n\t * matches a query selector.\n\t * @private\n\t * @param node {Node}\n\t * @param selector {String}\n\t * @param handler {Function} function (e) {}\n\t * @returns {Function} function (e) {}\n\t */\n\tfunction filteringHandler (node, selector, handler) {\n\t\treturn function (e) {\n\t\t\tvar target, matches, i, len, match;\n\t\t\t// if e.target matches the selector, call the handler\n\t\t\ttarget = e.target;\n\t\t\tmatches = base.querySelectorAll(selector, node);\n\t\t\tfor (i = 0, len = matches.length; i < len; i++) {\n\t\t\t\tmatch = matches[i];\n\t\t\t\tif (target == match || contains(match, target)) {\n\t\t\t\t\te.selectorTarget = match;\n\t\t\t\t\treturn handler(e);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n});\n}(\n\ttypeof define == 'function' && define.amd\n\t\t? define\n\t\t: function (deps, factory) { module.exports = factory.apply(this, deps.map(require)); }\n));\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/lib/plugin-base/on.js":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * wire/plugin-base/on\n *\n * wire is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\n(function (define) {\ndefine(function (require) {\n'use strict';\n\n\tvar when, functional, connection,\n\t\ttheseAreNotEvents, thisLooksLikeCssRx, eventSplitterRx, undef;\n\n\twhen = require('when');\n\tfunctional = require('../functional');\n\tconnection = require('../connection');\n\n\ttheseAreNotEvents = {\n\t\tselector: 1,\n\t\ttransform: 1,\n\t\tpreventDefault: 1,\n\t\tstopPropagation: 1\n\t};\n\n\tthisLooksLikeCssRx = /#|\\.|-|[^,]\\s[^,]/;\n\teventSplitterRx = /\\s*,\\s*/;\n\n\treturn function createOnPlugin (options) {\n\t\tvar on;\n\n\t\ton = options.on;\n\n\t\treturn function eventsPlugin (options) {\n\n\t\t\tvar removers = [];\n\n\t\t\tif (!options) {\n\t\t\t\toptions = {};\n\t\t\t}\n\n\t\t\tfunction createConnection(nodeProxy, eventsString, handler) {\n\t\t\t\tvar events, node, prevent, stop;\n\n\t\t\t\tevents = splitEventSelectorString(eventsString);\n\t\t\t\tnode = nodeProxy.target;\n\t\t\t\tprevent = options.preventDefault;\n\t\t\t\tstop = options.stopPropagation;\n\n\t\t\t\tremovers = removers.concat(\n\t\t\t\t\tregisterHandlers(events, node, handler, prevent, stop)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tfunction parseIncomingOn(srcProxy, targetProxy, connections, wire) {\n\n\t\t\t\t// NOTE: Custom parsing for incoming connections\n\n\t\t\t\t// target is the node to which to connect, and\n\t\t\t\t// right hand side is a specification of an event\n\t\t\t\t// and a handler method on the current component\n\t\t\t\t//\n\t\t\t\t//\tcomponent: {\n\t\t\t\t//\t\ton: {\n\t\t\t\t//\t\t\totherComponent: {\n\t\t\t\t//\t\t\t\tselector: 'a.nav',\n\t\t\t\t//\t\t\t\ttransform: { $ref: 'myTransformFunc' }, // optional\n\t\t\t\t//\t\t\t\tclick: 'handlerMethodOnComponent',\n\t\t\t\t//\t\t\t\tkeypress: 'anotherHandlerOnComponent'\n\t\t\t\t//\t\t\t}\n\t\t\t\t//\t\t}\n\t\t\t\t//\t}\n\t\t\t\tvar target, event, events, selector, prevent, stop, method, transform, promises;\n\n\t\t\t\ttarget = targetProxy.target;\n\t\t\t\tpromises = [];\n\n\t\t\t\t// Extract options\n\t\t\t\tselector = connections.selector;\n\t\t\t\ttransform = connections.transform;\n\t\t\t\tprevent = connections.preventDefault || options.preventDefault;\n\t\t\t\tstop = connections.stopPropagation || options.stopPropagation;\n\n\t\t\t\t/**\n\t\t\t\t * Compose a transform pipeline and then pass it to addConnection\n\t\t\t\t */\n\t\t\t\tfunction createTransformedConnection(events, targetMethod, transformPromise) {\n\t\t\t\t\treturn when(transformPromise, function(transform) {\n\t\t\t\t\t\tvar composed, node;\n\n\t\t\t\t\t\tnode = srcProxy.target;\n\t\t\t\t\t\tcomposed = functional.compose([transform, targetMethod]);\n\t\t\t\t\t\t\t//.bind(targetProxy.target);\n\n\t\t\t\t\t\tremovers = removers.concat(\n\t\t\t\t\t\t\tregisterHandlers(events, node, function() {\n\t\t\t\t\t\t\t\treturn targetProxy.invoke(composed, arguments);\n\t\t\t\t\t\t\t}, prevent, stop)\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tfor (event in connections) {\n\t\t\t\t\t// Skip reserved names, such as 'selector'\n\t\t\t\t\tif (!(event in theseAreNotEvents)) {\n\t\t\t\t\t\t// If there's an explicit transform, compose a transform pipeline manually,\n\t\t\t\t\t\t// Otherwise, let the connection lib do it's thing\n\t\t\t\t\t\tif(transform) {\n\t\t\t\t\t\t\t// TODO: Remove this long form?  It'd simplify the code a lot\n\t\t\t\t\t\t\tevents = splitEventSelectorString(event, selector);\n\t\t\t\t\t\t\tmethod = connections[event];\n\t\t\t\t\t\t\tpromises.push(createTransformedConnection(events, target[method], wire(transform)));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpromises.push(connection.parseIncoming(srcProxy, event, targetProxy, options, connections[event], wire, createConnection));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn when.all(promises);\n\t\t\t}\n\n\t\t\tfunction parseOn (proxy, refName, connections, wire) {\n\t\t\t\t// First, figure out if the left-hand-side is a ref to\n\t\t\t\t// another component, or an event/delegation string\n\t\t\t\treturn when(wire.getProxy(refName),\n\t\t\t\t\tfunction (srcProxy) {\n\t\t\t\t\t\t// It's an incoming connection, parse it as such\n\t\t\t\t\t\treturn parseIncomingOn(srcProxy, proxy, connections, wire);\n\t\t\t\t\t},\n\t\t\t\t\tfunction () {\n\t\t\t\t\t\t// Failed to resolve refName as a reference, assume it\n\t\t\t\t\t\t// is an outgoing event with the current component (which\n\t\t\t\t\t\t// must be a Node) as the source\n\t\t\t\t\t\treturn connection.parseOutgoing(proxy, refName, connections, wire, createConnection);\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tfunction onFacet (wire, facet) {\n\t\t\t\tvar promises, connections;\n\n\t\t\t\tconnections = facet.options;\n\t\t\t\tpromises = [];\n\n\t\t\t\tfor (var ref in connections) {\n\t\t\t\t\tpromises.push(parseOn(facet, ref, connections[ref], wire));\n\t\t\t\t}\n\n\t\t\t\treturn when.all(promises);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tcontext: {\n\t\t\t\t\tdestroy: function(resolver) {\n\t\t\t\t\t\tremovers.forEach(function(remover) {\n\t\t\t\t\t\t\tremover();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tresolver.resolve();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfacets: {\n\t\t\t\t\ton: {\n\t\t\t\t\t\tconnect: function (resolver, facet, wire) {\n\t\t\t\t\t\t\tresolver.resolve(onFacet(wire, facet));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tresolvers: {\n\t\t\t\t\ton: function(resolver, name /*, refObj, wire*/) {\n\t\t\t\t\t\tresolver.resolve(name ? createOnResolver(name) : on);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\n\t\tfunction registerHandlers (events, node, callback, prevent, stop) {\n\t\t\tvar removers, handler;\n\t\t\tremovers = [];\n\t\t\tfor (var i = 0, len = events.length; i < len; i++) {\n\t\t\t\thandler = makeEventHandler(callback, prevent, stop);\n\t\t\t\tremovers.push(on(node, events[i], handler, events.selector));\n\t\t\t}\n\t\t\treturn removers;\n\t\t}\n\n\t\t/**\n\t\t * Returns a function that creates event handlers.  The event handlers\n\t\t * are pre-configured with one or more selectors and one\n\t\t * or more event types.  The syntax is identical to the \"on\" facet.\n\t\t * Note that the returned handler does not auto-magically call\n\t\t * event.preventDefault() or event.stopPropagation() like the \"on\"\n\t\t * facet does.\n\t\t * @private\n\t\t * @param eventSelector {String} event/selector string that can be\n\t\t *   parsed by splitEventSelectorString()\n\t\t * @return {Function} a function that can be used to create event\n\t\t *   handlers. It returns an \"unwatch\" function and takes any of\n\t\t *   the following argument signatures:\n\t\t *     function (handler) {}\n\t\t *     function (rootNode, handler) {}\n\t\t */\n\t\tfunction createOnResolver (eventSelector) {\n\t\t\tvar events;\n\t\t\t// split event/selector string\n\t\t\tevents = splitEventSelectorString(eventSelector, '');\n\t\t\treturn function () {\n\t\t\t\tvar args, node, handler, unwatches;\n\t\t\t\t// resolve arguments\n\t\t\t\targs = Array.prototype.slice.call(arguments, 0, 3);\n\t\t\t\tnode = args.length > 1 ? args.shift() : document;\n\t\t\t\thandler = args[0];\n\n\t\t\t\tunwatches = [];\n\t\t\t\tevents.forEach(function (event) {\n\t\t\t\t\t// create a handler for each event\n\t\t\t\t\tunwatches.push(on(node, event, handler, events.selector));\n\t\t\t\t});\n\t\t\t\t// return unwatcher of all events\n\t\t\t\treturn function () {\n\t\t\t\t\tunwatches.forEach(function (unwatch) { unwatch(); });\n\t\t\t\t};\n\t\t\t};\n\t\t}\n\n\t};\n\n\tfunction preventDefaultIfNav (e) {\n\t\tvar node, nodeName, nodeType, isNavEvent;\n\t\tnode = e.selectorTarget || e.target || e.srcElement;\n\t\tif (node) {\n\t\t\tnodeName = node.tagName;\n\t\t\tnodeType = node.type && node.type.toLowerCase();\n\t\t\t// catch links and submit buttons/inputs in forms\n\t\t\tisNavEvent = ('click' == e.type && 'A' == nodeName)\n\t\t\t\t|| ('click' == e.type && 'submit' == nodeType && node.form)\n\t\t\t\t|| ('submit' == e.type && 'FORM' == nodeName);\n\t\t\tif (isNavEvent) {\n\t\t\t\tpreventDefaultAlways(e);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction preventDefaultAlways (e) {\n\t\te.preventDefault();\n\t}\n\n\tfunction stopPropagationAlways (e) {\n\t\te.stopPropagation();\n\t}\n\n\tfunction never () {}\n\n\tfunction makeEventHandler (handler, prevent, stop) {\n\t\tvar preventer, stopper;\n\t\tpreventer = prevent == undef || prevent == 'auto'\n\t\t\t? preventDefaultIfNav\n\t\t\t: prevent ? preventDefaultAlways : never;\n\t\tstopper = stop ? stopPropagationAlways : never;\n\n\t\t// Use proxy.invoke instead of trying to call methods\n\t\t// directly on proxy.target\n\t\treturn function (e) {\n\t\t\tpreventer(e);\n\t\t\tstopper(e);\n\t\t\treturn handler.apply(this, arguments);\n\t\t};\n\t}\n\n\t/**\n\t * Splits an event-selector string into one or more combinations of\n\t * selectors and event types.\n\t * Examples:\n\t *   \".target:click\" --> {selector: '.target', event: 'click' }\n\t *   \".mylist:first-child:click, .mylist:last-child:click\" --> [\n\t *     { selector: '.mylist:first-child', event: 'click' },\n\t *     { selector: '.mylist:last-child', event: 'click' }\n\t *   ]\n\t *   \".mylist:first-child, .mylist:last-child:click\" --> {\n\t *     selector: '.mylist:first-child, .mylist:last-child',\n\t *     event: 'click'\n\t *   }\n\t * @private\n\t * @param string {String}\n\t * @param defaultSelector {String}\n\t * @returns {Array} an array of event names. if a selector was specified\n\t *   the array has a selectors {String} property\n\t */\n\tfunction splitEventSelectorString (string, defaultSelector) {\n\t\tvar split, events, selectors;\n\n\t\t// split on first colon to get events and selectors\n\t\tsplit = string.split(':', 2);\n\t\tevents = split[0];\n\t\tselectors = split[1] || defaultSelector;\n\n\t\t// look for css stuff in event (dev probably forgot event?)\n\t\t// css stuff: hash, dot, spaces without a comma\n\t\tif (thisLooksLikeCssRx.test(events)) {\n\t\t\tthrow new Error('on! resolver: malformed event-selector string (event missing?)');\n\t\t}\n\n\t\t// split events\n\t\tevents = events.split(eventSplitterRx);\n\t\tif (selectors) {\n\t\t\tevents.selector = selectors;\n\t\t}\n\n\t\treturn events;\n\t}\n\n});\n}(typeof define == 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/lib/dom/base.js":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * wire/dom/base\n * provides basic dom creation capabilities for plugins.\n *\n * wire is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\n(function (define) {\ndefine(function (require) {\n\n\tvar WireProxy, priority, classRx, trimLeadingRx, splitClassNamesRx, nodeProxyInvoke;\n\n\tWireProxy = require('../WireProxy');\n\tpriority = require('../plugin/priority');\n\n\tclassRx = '(\\\\s+|^)(classNames)(\\\\b(?![\\\\-_])|$)';\n\ttrimLeadingRx = /^\\s+/;\n\tsplitClassNamesRx = /(\\b\\s+\\b)|(\\s+)/g;\n\n\t/**\n\t * Adds one or more css classes to a dom element.\n\t * @param el {HTMLElement}\n\t * @param className {String} a single css class or several, space-delimited\n\t *   css classes.\n\t */\n\tfunction addClass (el, className) {\n\t\tvar newClass;\n\n\t\tnewClass = _stripClass(el.className, className);\n\n\t\tel.className = newClass + (newClass && className ? ' ' : '') + className;\n\t}\n\n\t/**\n\t * Removes one or more css classes from a dom element.\n\t * @param el {HTMLElement}\n\t * @param className {String} a single css class or several, space-delimited\n\t *   css classes.\n\t */\n\tfunction removeClass (el, className) {\n\t\tel.className = _stripClass(el.className, className);\n\t}\n\n\t/**\n\t * Adds or removes one or more css classes from a dom element.\n\t * @param el {HTMLElement}\n\t * @param className {String} a single css class or several, space-delimited\n\t *   css classes.\n\t */\n\tfunction toggleClass (el, className) {\n\t\tvar unalteredClass;\n\n\t\t// save copy of what _stripClass would return if className\n\t\t// was not found\n\t\tunalteredClass = el.className.replace(trimLeadingRx, '');\n\n\t\t// remove className\n\t\tel.className = _stripClass(el.className, className);\n\n\t\t// add className if it wasn't removed\n\t\tif (unalteredClass == el.className) {\n\t\t\tel.className = unalteredClass + (unalteredClass && className ? ' ' : '') + className;\n\t\t}\n\t}\n\n\t/**\n\t * Super fast, one-pass, non-looping routine to remove one or more\n\t * space-delimited tokens from another space-delimited set of tokens.\n\t * @private\n\t * @param tokens\n\t * @param removes\n\t */\n\tfunction _stripClass (tokens, removes) {\n\t\tvar rx;\n\n\t\tif (!removes) {\n\t\t\treturn tokens;\n\t\t}\n\n\t\t// convert space-delimited tokens with bar-delimited (regexp `or`)\n\t\tremoves = removes.replace(splitClassNamesRx, function (m, inner, edge) {\n\t\t\t// only replace inner spaces with |\n\t\t\treturn edge ? '' : '|';\n\t\t});\n\n\t\t// create one-pass regexp\n\t\trx = new RegExp(classRx.replace('classNames', removes), 'g');\n\n\t\t// remove all tokens in one pass (wish we could trim leading\n\t\t// spaces in the same pass! at least the trim is not a full\n\t\t// scan of the string)\n\t\treturn tokens.replace(rx, '').replace(trimLeadingRx, '');\n\t}\n\n\tif (document && document.appendChild.apply) {\n\t\t// normal browsers\n\t\tnodeProxyInvoke = function jsInvoke (node, method, args) {\n\t\t\tif(typeof method == 'string') {\n\t\t\t\tmethod = node[method];\n\t\t\t}\n\t\t\treturn method.apply(node, args);\n\t\t};\n\t}\n\telse {\n\t\t// IE 6-8 ('native' methods don't have .apply()) so we have\n\t\t// to use eval())\n\t\tnodeProxyInvoke = function evalInvoke (node, method, args) {\n\t\t\tvar argsList;\n\n\t\t\tif(typeof method == 'function') {\n\t\t\t\treturn method.apply(node, args);\n\t\t\t}\n\n\t\t\t// iirc, no node methods have more than 4 parameters\n\t\t\t// (addEventListener), so 5 should be safe. Note: IE needs\n\t\t\t// the exact number of arguments or it will throw!\n\t\t\targsList = ['a', 'b', 'c', 'd', 'e'].slice(0, args.length).join(',');\n\n\t\t\t// function to execute eval (no need for global eval here\n\t\t\t// since the code snippet doesn't reference out-of-scope vars).\n\t\t\tfunction invoke (a, b, c, d, e) {\n\t\t\t\t/*jshint evil:true*/\n\t\t\t\t/*jshint unused:false*/\n\t\t\t\treturn eval('node.' + method + '(' + argsList + ');');\n\t\t\t}\n\n\t\t\t// execute and return result\n\t\t\treturn invoke.apply(this, args);\n\t\t};\n\t}\n\n\tfunction byId(id) {\n\t\treturn document.getElementById(id);\n\t}\n\n\tfunction queryAll(selector, root) {\n\t\treturn (root||document).querySelectorAll(selector);\n\t}\n\n\tfunction query(selector, root) {\n\t\treturn (root||document).querySelector(selector);\n\t}\n\n\t/**\n\t * Places a node into the DOM at the location specified around\n\t * a reference node.\n\t * Note: replace is problematic if the dev expects to use the node\n\t * as a wire component.  The component reference will still point\n\t * at the node that was replaced.\n\t * @param node {HTMLElement}\n\t * @param refNode {HTMLElement}\n\t * @param location {String} or {Number} 'before', 'after', 'first', 'last',\n\t *   or the position within the children of refNode\n\t */\n\tfunction placeAt(node, refNode, location) {\n\t\tvar parent, i;\n\n\t\tif ('length' in refNode) {\n\t\t\tfor (i = 0; i < refNode.length; i++) {\n\t\t\t\tplaceAt(i === 0 ? node : node.cloneNode(true), refNode[i], location);\n\t\t\t}\n\t\t\treturn node;\n\t\t}\n\n\t\tparent = refNode.parentNode;\n\n\t\t// `if else` is more compressible than switch\n\t\tif (!isNaN(location)) {\n\t\t\tif (location < 0) {\n\t\t\t\tlocation = 0;\n\t\t\t}\n\t\t\t_insertBefore(refNode, node, refNode.childNodes[location]);\n\t\t}\n\t\telse if(location == 'at') {\n\t\t\trefNode.innerHTML = '';\n\t\t\t_appendChild(refNode, node);\n\t\t}\n\t\telse if(location == 'last') {\n\t\t\t_appendChild(refNode, node);\n\t\t}\n\t\telse if(location == 'first') {\n\t\t\t_insertBefore(refNode, node, refNode.firstChild);\n\t\t}\n\t\telse if(location == 'before') {\n\t\t\t// TODO: throw if parent missing?\n\t\t\t_insertBefore(parent, node, refNode);\n\t\t}\n\t\telse if(location == 'after') {\n\t\t\t// TODO: throw if parent missing?\n\t\t\tif (refNode == parent.lastChild) {\n\t\t\t\t_appendChild(parent, node);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_insertBefore(parent, node, refNode.nextSibling);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthrow new Error('Unknown dom insertion command: ' + location);\n\t\t}\n\n\t\treturn node;\n\t}\n\n\t// these are for better compressibility since compressors won't\n\t// compress native DOM methods.\n\tfunction _insertBefore(parent, node, refNode) {\n\t\tparent.insertBefore(node, refNode);\n\t}\n\n\tfunction _appendChild(parent, node) {\n\t\tparent.appendChild(node);\n\t}\n\n\tfunction isNode(it) {\n\t\treturn typeof Node === 'object'\n\t\t\t? it instanceof Node\n\t\t\t: it && typeof it === 'object' && typeof it.nodeType === 'number' && typeof it.nodeName==='string';\n\t}\n\n\tfunction NodeProxy() {}\n\n\tNodeProxy.prototype = {\n\t\tget: function (name) {\n\t\t\tvar node = this.target;\n\n\t\t\tif (name in node) {\n\t\t\t\treturn node[name];\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn node.getAttribute(name);\n\t\t\t}\n\t\t},\n\n\t\tset: function (name, value) {\n\t\t\tvar node = this.target;\n\n\t\t\tif (name in node) {\n\t\t\t\treturn node[name] = value;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn node.setAttribute(name, value);\n\t\t\t}\n\t\t},\n\n\t\tinvoke: function (method, args) {\n\t\t\treturn nodeProxyInvoke(this.target, method, args);\n\t\t},\n\n\t\tdestroy: function () {\n\t\t\tvar node = this.target;\n\n\t\t\t// if we added a destroy method on the node, call it.\n\t\t\t// TODO: find a better way to release events instead of using this mechanism\n\t\t\tif (node.destroy) {\n\t\t\t\tnode.destroy();\n\t\t\t}\n\t\t\t// removal from document will destroy node as soon as all\n\t\t\t// references to it go out of scope.\n\t\t\tvar parent = node.parentNode;\n\t\t\tif (parent) {\n\t\t\t\tparent.removeChild(node);\n\t\t\t}\n\t\t},\n\n\t\tclone: function (options) {\n\t\t\tif (!options) {\n\t\t\t\toptions = {};\n\t\t\t}\n\t\t\t// default is to clone deep (when would anybody not want deep?)\n\t\t\treturn this.target.cloneNode(!('deep' in options) || options.deep);\n\t\t}\n\t};\n\n\tproxyNode.priority = priority.basePriority;\n\tfunction proxyNode (proxy) {\n\n\t\tif (!isNode(proxy.target)) {\n\t\t\treturn proxy;\n\t\t}\n\n\t\treturn WireProxy.extend(proxy, NodeProxy.prototype);\n\t}\n\n\treturn {\n\n\t\tbyId: byId,\n\t\tquerySelector: query,\n\t\tquerySelectorAll: queryAll,\n\t\tplaceAt: placeAt,\n\t\taddClass: addClass,\n\t\tremoveClass: removeClass,\n\t\ttoggleClass: toggleClass,\n\t\tproxyNode: proxyNode\n\n\t};\n\n});\n}(\n\ttypeof define == 'function' && define.amd\n\t\t? define\n\t\t: function (factory) { module.exports = factory(require); }\n));\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/sizzle.js":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * wire/sizzle plugin\n * Adds querySelectorAll functionality to wire using John Resig's Sizzle library.\n * Sizzle must be wrapped in an AMD define().  Kris Zyp has a version of this at\n * http://github.com/kriszyp/sizzle\n *\n * wire is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @author John Hann (@unscriptable)\n */\n\ndefine(['./lib/plugin-base/dom', 'sizzle'], function(createDomPlugin, sizzle) {\n\n\t/**\n\t * The usual addClass function\n\t *\n\t * @param node\n\t * @param cls {String} space separated list of classes\n\t */\n\tfunction addClass(node, cls) {\n\t\tvar className = node.className ? ' ' + node.className + ' ' : '';\n\n\t\tcls = cls.split(/\\s+/);\n\n\t\tfor (var i = 0, len = cls.length; i < len; i++) {\n\t\t\tvar c = ' ' + cls[i];\n\t\t\tif(className.indexOf(c + ' ') < 0) {\n\t\t\t\tclassName += c;\n\t\t\t}\n\t\t}\n\n\t\tnode.className = className.slice(1, className.length);\n\t}\n\n\t/**\n\t * The usual removeClass function\n\t *\n\t * @param node\n\t * @param cls {String} space separated list of classes\n\t */\n\tfunction removeClass(node, cls) {\n\t\tvar className = ' ' + node.className + ' ';\n\n\t\tcls = cls.split(/\\s+/);\n\n\t\tfor (var i = 0, len = cls.length; i < len; i++) {\n\t\t\tvar c = ' ' + cls[i] + ' ';\n\t\t\tclassName = className.replace(c, ' ');\n\t\t}\n\n\t\tnode.className = className.replace(/(^\\s+|\\s+$)/g, '');\n\t}\n\n\treturn createDomPlugin({\n\t\tquery: sizzle,\n\t\tfirst: function (selector, root) {\n\t\t\treturn sizzle(selector, root)[0];\n\t\t},\n\t\taddClass: addClass,\n\t\tremoveClass: removeClass\n\t});\n\n});\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/builder/cram.js":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * wire/cram/builder plugin\n * Builder plugin for cram\n * https://github.com/cujojs/cram\n *\n * wire is part of the cujoJS family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\n(function(define) {\ndefine(function(require) {\n\n\tvar when, unfold, mid, defaultModuleRegex, defaultSpecRegex, replaceIdsRegex,\n\t\tremoveCommentsRx, splitIdsRegex;\n\n\twhen = require('when');\n\tunfold = require('when/unfold');\n\tmid = require('../lib/loader/moduleId');\n\n\t// default dependency regex\n\tdefaultModuleRegex = /\\.(module|create)$/;\n\tdefaultSpecRegex = /\\.(wire\\.spec|wire)$/;\n\t// adapted from cram's scan function:\n\t//replaceIdsRegex = /(define)\\s*\\(\\s*(?:\\s*[\"']([^\"']*)[\"']\\s*,)?(?:\\s*\\[([^\\]]+)\\]\\s*,)?\\s*(function)?\\s*(?:\\(([^)]*)\\))?/g;\n\t//replaceIdsRegex = /(define)\\s*\\(\\s*(?:\\s*[\"']([^\"']*)[\"']\\s*,)?(?:\\s*\\[([^\\]]*)\\]\\s*,)?/;\n\treplaceIdsRegex = /(\\bdefine)\\s*\\(\\s*(?:\\s*'([^']*)'|\"([^\"]*)\"\\s*,)?(?:\\s*\\[([^\\]]*)\\]\\s*,)?/;\n\tremoveCommentsRx = /\\/\\*[\\s\\S]*?\\*\\//g;\n\tsplitIdsRegex = /\\s*,\\s*/;\n\n\treturn {\n\t\tnormalize: normalize,\n\t\tcompile: compile\n\t};\n\n\tfunction normalize(resourceId, toAbsId) {\n\t\treturn resourceId ? toAbsId(resourceId.split(\"!\")[0]) : resourceId;\n\t}\n\n\tfunction compile(wireId, resourceId, require, io, config) {\n\t\t// Track all modules seen in wire spec, so we only include them once\n\t\tvar specIds, defines, seenModules, childSpecRegex,\n\t\t\tmoduleRegex;\n\n\t\tdefines = [];\n\t\tseenModules = {};\n\t\tmoduleRegex = defaultModuleRegex;\n\t\tchildSpecRegex = defaultSpecRegex;\n\n\t\t// Get config values\n\t\tif(config) {\n\t\t\tif(config.moduleRegex) moduleRegex = new RegExp(config.moduleRegex);\n\t\t\tif(config.childSpecRegex) childSpecRegex = new RegExp(config.childSpecRegex);\n\t\t}\n\n\t\t// Grab the spec module id, *or comma separated list of spec module ids*\n\t\t// Split in case it's a comma separated list of spec ids\n\t\tspecIds = resourceId.split(splitIdsRegex);\n\n\t\treturn when.map(specIds, function(specId) {\n\t\t\treturn processSpec(specId);\n\t\t}).then(write, io.error);\n\n\t\t// For each spec id, add the spec itself as a dependency, and then\n\t\t// scan the spec contents to find all modules that it needs (e.g.\n\t\t// \"module\" and \"create\")\n\t\tfunction processSpec(specId) {\n\t\t\tvar dependencies, ids;\n\n\t\t\tdependencies = [];\n\t\t\tids = [specId];\n\n\t\t\t_addDep(wireId);\n\n\t\t\treturn unfold(fetchNextSpec, endOfList, scanSpec, ids)\n\t\t\t\t.then(function() {\n\t\t\t\t\treturn generateDefine(specId, dependencies);\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tfunction fetchNextSpec() {\n\t\t\t\tvar id = ids.shift();\n\t\t\t\treturn when.promise(function(resolve, reject) {\n\t\t\t\t\trequire(\n\t\t\t\t\t\t[id],\n\t\t\t\t\t\tfunction(spec) { resolve([{ spec: spec, id: id }, ids]); },\n\t\t\t\t\t\treject\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction _addDep(moduleId) {\n\t\t\t\tif(!(moduleId in seenModules)) {\n\t\t\t\t\tdependencies.push(moduleId);\n\t\t\t\t\tseenModules[moduleId] = moduleId;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction scanSpec(specDescriptor) {\n\t\t\t\tvar spec = specDescriptor.spec;\n\n\t\t\t\tscanPlugins(spec);\n\t\t\t\tscanObj(spec);\n\n\t\t\t\tfunction resolveId(moduleId) {\n\t\t\t\t\treturn mid.resolve(specDescriptor.id, moduleId)\n\t\t\t\t}\n\n\t\t\t\tfunction scanObj(obj, path) {\n\t\t\t\t\t// Scan all keys.  This might be the spec itself,\n\t\t\t\t\t// or any sub-object-literal in the spec.\n\t\t\t\t\tfor (var name in obj) {\n\t\t\t\t\t\tscanItem(obj[name], createPath(path, name));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction scanItem(it, path) {\n\t\t\t\t\t// Determine the kind of thing we're looking at\n\t\t\t\t\t// 1. If it's a string, and the key is module or create, then assume it\n\t\t\t\t\t//    is a moduleId, and add it as a dependency.\n\t\t\t\t\t// 2. If it's an object or an array, scan it recursively\n\t\t\t\t\t// 3. If it's a wire spec, add it to the list of spec ids\n\t\t\t\t\tif (isSpec(path) && typeof it === 'string') {\n\t\t\t\t\t\taddSpec(it);\n\n\t\t\t\t\t} else if (isDep(path) && typeof it === 'string') {\n\t\t\t\t\t\t// Get module def\n\t\t\t\t\t\taddDep(it);\n\n\t\t\t\t\t} else if (isStrictlyObject(it)) {\n\t\t\t\t\t\t// Descend into subscope\n\t\t\t\t\t\tscanObj(it, path);\n\n\t\t\t\t\t} else if (Array.isArray(it)) {\n\t\t\t\t\t\t// Descend into array\n\t\t\t\t\t\tvar arrayPath = path + '[]';\n\t\t\t\t\t\tit.forEach(function(arrayItem) {\n\t\t\t\t\t\t\tscanItem(arrayItem, arrayPath);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction scanPlugins(spec) {\n\t\t\t\t\tvar plugins = spec.$plugins || spec.plugins;\n\n\t\t\t\t\tif(Array.isArray(plugins)) {\n\t\t\t\t\t\tplugins.forEach(addPlugin);\n\t\t\t\t\t} else if(typeof plugins === 'object') {\n\t\t\t\t\t\tObject.keys(plugins).forEach(function(key) {\n\t\t\t\t\t\t\taddPlugin(plugins[key]);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction addPlugin(plugin) {\n\t\t\t\t\tif(typeof plugin === 'string') {\n\t\t\t\t\t\taddDep(plugin);\n\t\t\t\t\t} else if(typeof plugin === 'object' && plugin.module) {\n\t\t\t\t\t\taddDep(plugin.module);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction addDep(moduleId) {\n\t\t\t\t\t_addDep(resolveId(moduleId));\n\t\t\t\t}\n\n\t\t\t\tfunction addSpec(specId) {\n\t\t\t\t\tspecId = resolveId(specId);\n\t\t\t\t\tif(!(specId in seenModules)) {\n\t\t\t\t\t\tids.push(specId);\n\t\t\t\t\t}\n\t\t\t\t\t_addDep(specId);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateDefine(specId, dependencies) {\n\t\t\tvar dfd, buffer;\n\n\t\t\tdfd = when.defer();\n\n\t\t\tio.read(ensureExtension(specId, 'js'), function(specText) {\n\t\t\t\tbuffer = injectIds(specText, specId, dependencies);\n\n\t\t\t\tdefines.push(buffer);\n\t\t\t\tdfd.resolve();\n\n\t\t\t}, dfd.reject);\n\n\t\t\treturn dfd.promise;\n\t\t}\n\n\t\tfunction write() {\n\t\t\t// protect against prior code that may have omitted a semi-colon\n\t\t\tio.write('\\n;' + defines.join('\\n'));\n\t\t}\n\n\t\tfunction isDep(path) {\n\t\t\treturn moduleRegex.test(path);\n\t\t}\n\n\t\tfunction isSpec(path) {\n\t\t\treturn childSpecRegex.test(path);\n\t\t}\n\t}\n\n\tfunction createPath(path, name) {\n\t\treturn path ? (path + '.' + name) : name\n\t}\n\n\tfunction isStrictlyObject(it) {\n\t\treturn (it && Object.prototype.toString.call(it) == '[object Object]');\n\t}\n\n\tfunction ensureExtension(id, ext) {\n\t\treturn id.lastIndexOf('.') <= id.lastIndexOf('/')\n\t\t\t? id + '.' + ext\n\t\t\t: id;\n\t}\n\n\tfunction injectIds(moduleText, absId, moduleIds) {\n\t\tvar replaced, newText;\n\t\t// note: replaceIdsRegex removes commas, parens, and brackets\n\t\tnewText = moduleText.replace(removeCommentsRx, '').replace(replaceIdsRegex, function (m, def, mid1, mid2, depIds) {\n\t\t\treplaced = true;\n\t\t\t// merge deps, but not args since they're not referenced in module\n\t\t\tif(depIds) {\n\t\t\t\tmoduleIds = depIds.split(splitIdsRegex).concat(moduleIds);\n\t\t\t}\n\n\t\t\tmoduleIds = '[' + moduleIds.map(quoted).join(', ') + '], ';\n\n\t\t\treturn def + '(' + quoted(absId) + ', ' + moduleIds;\n\t\t});\n\t\tif (!replaced) {\n\t\t\tthrow new Error('Unable to parse AMD define() in ' + absId);\n\t\t}\n\t\treturn newText;\n\t}\n\n\tfunction quoted(id) {\n\t\treturn '\"' + id + '\"';\n\t}\n\n\tfunction endOfList(ids) {\n\t\treturn !ids.length;\n\t}\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/dojo/data.js":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * wire/dojo/data plugin\n * wire plugin that provides a REST resource reference resolver.  Referencing\n * any REST resource using the format: resource!url/goes/here will create a\n * dojo.store.JsonRest pointing to url/goes/here.  Using the id or query\n * options, you can alternatively resolve references to actual data.\n *\n * wire is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\n\ndefine(function() {\n\n\tvar pluginInstance;\n\n\t/**\n     * Reference resolver for \"datastore!url\" for easy references to\n     * legacy dojo/data datastores.\n     * \n     * @param resolver\n     * @param name\n     * @param refObj\n     * @param wire\n     */\n    function dataStoreResolver(resolver, name, refObj, wire) {\n\n        var dataStore = wire({\n            create: {\n                module: 'dojo/data/ObjectStore',\n                args: {\n                    objectStore: {\n                        create: {\n                            module: 'dojo/store/JsonRest',\n                            args: { target: name }\n                        }\n                    }\n                }\n            }\n        });\n\n\t\tresolver.resolve(dataStore);\n    }\n\n\t/**\n\t * The plugin instance.  Can be the same for all wiring runs\n\t */\n\tpluginInstance = {\n\t\tresolvers: {\n\t\t\tdatastore: dataStoreResolver\n\t\t}\n\t};\n\n    return {\n        wire$plugin: function datastorePlugin(/* options */) {\n            return pluginInstance;\n        }\n    };\n});","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/dojo/dijit.js":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * wire/dojo/dijit plugin\n * wire plugin that provides a reference resolver for dijits declared using\n * dojoType/data-dojo-type, a setter that can set dojo 1.6+ set(name, value)\n * style properties, a wire$init() function that invokes the dojo parser,\n * and an object lifecycle handler that will cleanup (e.g. destroyRecursive,\n * or destroy) dijits instantiated \"programmatically\" in a wiring context.\n *\n * wire is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\n\ndefine(['dojo', 'dojo/parser', 'dijit', 'dijit/_Widget', '../lib/WireProxy'], function(dojo, parser, dijit, Widget, WireProxy) {\n    var parsed, isArray, loadTheme, placeAtFacet, pluginInstance;\n\n    parsed = false;\n\n    isArray = dojo.isArray;\n\n    /**\n     * Resolver for dijits by id.  Uses dijit.byId\n     * @param name dijit id to resolve\n     */\n    function dijitById(promise, name /*, refObj, wire */) {\n        dojo.ready(\n            function() {\n                var resolved = dijit.byId(name);\n\n                if (resolved) {\n                    promise.resolve(resolved);\n                } else {\n                    throw new Error(\"No dijit with id: \" + name);\n                }\n            }\n        );\n    }\n\n    function isDijit(it) {\n        // NOTE: It is possible to create inheritance hierarchies with dojo.declare\n        // where the following evaluates to false *even though* dijit._Widget is\n        // most certainly an ancestor of it.\n        // So, may need to modify this test if that seems to happen in practice.\n        return it instanceof Widget;\n    }\n\n\tvar dijitProxy = {\n\t\tget: function(name) {\n\t\t\treturn this.target.get(name);\n\t\t},\n\t\tset: function(name, val) {\n\t\t\treturn this.target.set(name, val);\n\t\t},\n\t\tdestroy: function() {\n\t\t\treturn destroyDijit(this.target);\n\t\t},\n\t\tclone: function() {\n\t\t\treturn dojo.clone(this.target);\n\t\t}\n\t};\n\n    function proxyDijit(proxy) {\n        if (isDijit(proxy.target)) {\n\t\t\treturn WireProxy.extend(proxy, dijitProxy);\n        }\n    }\n\n    function destroyDijit(target) {\n        // Prefer destroyRecursive over destroy\n        if (typeof target.destroyRecursive == 'function') {\n            target.destroyRecursive(false);\n        } else if (typeof target.destroy == 'function') {\n            target.destroy(false);\n        }\n    }\n\n    loadTheme = function(theme) {\n        // Clobber loadTheme so we only do it once?\n        loadTheme = function() {};\n\n        // Rely on the AMD css! plugin for now\n        require(['css!' + 'dijit/themes/' + theme + '/' + theme + '.css']);\n        dojo.addClass(dojo.body(), theme);\n    };\n\n    placeAtFacet = {\n        /**\n         * Provides a placeAt feature for dijits in the wire spec.\n         * Usage:\n         *      {\n         *          create: //create a dijit\n         *          placeAt: { $ref: 'dom!targetNode }\n         *      }\n         * @param resolver\n         * @param proxy\n         * @param wire\n         */\n        initialize: function(resolver, proxy, wire) {\n            var dijit, nodeRef;\n\n            dijit = proxy.target;\n            nodeRef = proxy.options;\n\n            if (isDijit(dijit)) {\n                wire(nodeRef).then(\n                    function(args) {\n                        dijit.placeAt.apply(dijit, isArray(args) ? args : [args]);\n                        resolver.resolve();\n                    },\n                    function(e) {\n                        resolver.reject(e);\n                    }\n                );\n            } else {\n                resolver.reject(new Error(\"Not a dijit: \" + proxy.path));\n            }\n        }\n    };\n\n\tpluginInstance = {\n\t\tresolvers:{\n\t\t\tdijit:dijitById\n\t\t},\n\t\tproxies:[\n\t\t\tproxyDijit\n\t\t],\n\t\tfacets: {\n\t\t\tplaceAt: placeAtFacet\n\t\t}\n\t};\n\n    return {\n        wire$plugin:function(options) {\n            // Only ever parse the page once, even if other child\n            // contexts are created with this plugin present.\n            if (options.parse && !parsed) {\n                parsed = true;\n                dojo.ready(function() {\n                    parser.parse();\n                });\n            }\n\n            var theme = options.theme;\n\n            if (theme) loadTheme(theme);\n\n            // Return plugin\n            return pluginInstance;\n        }\n    };\n});","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/dojo/dom.js":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * wire/dojo/dom plugin\n * Plugin that adds dom query resolver that uses dojo.query\n *\n * wire is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\n\ndefine(['../lib/plugin-base/dom', 'dojo'], function(createDomPlugin, dojo) {\n\n\treturn createDomPlugin({\n\t\tbyId: dojo.byId,\n\t\tquery: dojo.query,\n\t\tfirst: function () {\n\t\t\treturn dojo.query.apply(dojo, arguments)[0];\n\t\t},\n\t\taddClass: dojo.addClass,\n\t\tremoveClass: dojo.removeClass,\n\t\tplaceAt: function (node, refNode, location) {\n\t\t\tvar i;\n\t\t\tif ('length' in refNode) {\n\t\t\t\tfor (i = 0; i < refNode.length; i++) {\n\t\t\t\t\tdojo.place(i == 0 ? node : node.cloneNode(true), refNode[i], location);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdojo.place(node, refNode, location);\n\t\t\t}\n\t\t\treturn node;\n\t\t}\n\t});\n\n});","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/dojo/events.js":"/** @license MIT License (c) copyright 2011-2013 original author or authors */\n\n/**\n * wire/dojo/events plugin\n * wire plugin that can connect event handlers after an object is\n * initialized, and disconnect them when an object is destroyed.\n * This implementation uses dojo.connect and dojo.disconnect to do\n * the work of connecting and disconnecting event handlers.\n *\n * wire is part of the cujoJS family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @author Brian Cavalier\n * @author John Hann\n */\n\ndefine(['when', '../lib/connection', 'dojo', 'dojo/_base/event'],\nfunction(when, connection, events) {\n\n\treturn {\n\t\twire$plugin: function dojoEventsPlugin(/*, options*/) {\n\t\t\t\n\t\t\tvar connectHandles = [];\n\n\t\t\tfunction handleConnection(sourceProxy, eventName, handler) {\n\t\t\t\tconnectHandles.push(events.connect(sourceProxy.target, eventName, handler));\n\t\t\t}\n\n\t\t\tfunction connect(source, connect, options, wire) {\n\t\t\t\treturn connection.parse(source, connect, options, wire, handleConnection);\n\t\t\t}\n\t\t\t\n\t\t\t/*\n\t\t\t\tFunction: connectFacet\n\t\t\t\tSetup connections for each specified in the connects param.  Each key\n\t\t\t\tin connects is a reference, and the corresponding value is an object\n\t\t\t\twhose keys are event names, and whose values are methods of object to\n\t\t\t\tinvoke.  For example:\n\t\t\t\tconnect: {\n\t\t\t\t\t\"refToOtherThing\": {\n\t\t\t\t\t\t\"eventOrMethodOfOtherThing\": \"myOwnMethod\"\n\t\t\t\t\t},\n\t\t\t\t\t\"dom!myButton\": {\n\t\t\t\t\t\t\"onclick\": \"_handleButtonClick\"\n\t\t\t\t\t},\n\t\t\t\t\t\"dijit!myWidget\": {\n\t\t\t\t\t\t\"onChange\": \"_handleValueChange\"\n\t\t\t\t\t}\n\n\t\t\t\t\t\"myOwnEventOrMethod\": {\n\t\t\t\t\t\t\"refToOtherThing\": \"methodOfOtherThing\"\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tParameters:\n\t\t\t\t\tfactory - wiring factory\n\t\t\t\t\tobject - object being wired, will be the target of connected events\n\t\t\t\t\tconnects - specification of events to connect, see examples above.\n\t\t\t*/\n\t\t\tfunction connectFacet(wire, facet) {\n                var promises, connects;\n\n\t\t\t\tpromises = [];\n\t\t\t\tconnects = facet.options;\n\n\t\t\t\tfor(var ref in connects) {\n\t\t\t\t\tpromises.push(connect(facet, ref, connects[ref], wire));\n\t\t\t\t}\n\n                return when.all(promises);\n\t\t\t}\n\t\t\t\n\t\t\treturn {\n\t\t\t\tcontext: {\n\t\t\t\t\tdestroy: function(resolver) {\n\t\t\t\t\t\tfor (var i = connectHandles.length - 1; i >= 0; i--){\n\t\t\t\t\t\t\tevents.disconnect(connectHandles[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresolver.resolve();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfacets: {\n\t\t\t\t\tconnect: {\n\t\t\t\t\t\tconnect: function(resolver, facet, wire) {\n                            resolver.resolve(connectFacet(wire, facet));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t};\n});","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/dojo/on.js":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * wire/dojo/on plugin\n * wire plugin that provides an \"on\" facet that uses dojo/on (dojo 1.7\n * and later) to connect to dom events, and includes support for delegation\n *\n * wire is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\n(function (define) {\ndefine(['../lib/plugin-base/on', 'dojo/on', 'dojo/query'], function(createOnPlugin, dojoOn) {\n\n\t/**\n\t * Listens for dom events at the given node.  If a selector is provided,\n\t * events are filtered to only nodes matching the selector.  Note, however,\n\t * that children of the matching nodes can also fire events that bubble.\n\t * To determine the matching node, use the event object's selectorTarget\n\t * property instead of it's target property.\n\t * @param node {HTMLElement} element at which to listen\n\t * @param event {String} event name ('click', 'mouseenter')\n\t * @param handler {Function} handler function with the following signature: function (e) {}\n\t *   have the following signature: function (e) {}\n\t */\n\tfunction on (node, event, handler /*, selector */) {\n\t\tvar selector;\n\n\t\tselector = arguments[3];\n\n\t\tif (selector) {\n\t\t\tevent = dojoOn.selector(selector, event);\n\t\t}\n\n\t\t// dojo's lite selector relies on node.getAttribute, which will fail if\n\t\t// node is document.  So, substitute documentElement instead.\n\t\tif(node === document) node = document.documentElement;\n\n\t\treturn dojoOn(node, event, makeEventHandler(handler, selector)).remove;\n\t}\n\n\ton.wire$plugin = createOnPlugin({\n\t\ton: on\n\t});\n\n\treturn on;\n\n\tfunction makeEventHandler (handler, selector) {\n\t\treturn function (e) {\n\t\t\tif (selector) e.selectorTarget = this;\n\t\t\treturn handler(e);\n\t\t}\n\t}\n\n});\n}(\n\ttypeof define == 'function' && define.amd\n\t\t? define\n\t\t: function (deps, factory) { module.exports = factory.apply(this, deps.map(require)); }\n));\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/dojo/pubsub.js":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * wire/dojo/pubsub plugin\n * wire plugin that sets up subscriptions and topics to be published after\n * functions are invoked, and disconnect them when an object is destroyed.\n * This implementation uses dojo.publish, dojo.subscribe and dojo.unsubscribe\n * to do the work of connecting and disconnecting event handlers.\n *\n * wire is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\n\ndefine(['dojo', 'meld', 'dojo/_base/connect'], function(pubsub, meld) {\n\n\treturn {\n\t\twire$plugin: function pubsubPlugin(/*, options */) {\n\n\t\t\tvar destroyHandlers = [];\n\n\t\t\t/**\n\t\t\t * Add after advice to publish the result of target[method]\n\t\t\t * @param target {Object} target object\n\t\t\t * @param method {String} method name to which to apply advice\n\t\t\t * @param topic {String} dojo.publish topic on which to publish the result\n\t\t\t */\n\t\t\tfunction addPublishAdvice(target, method, topic) {\n\t\t\t\treturn meld.after(target, method, function(result) {\n\t\t\t\t\tpubsub.publish(topic, [result]);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Proxies methods on target so that they publish topics after\n\t\t\t * being invoked.  The payload of a topic will be the return\n\t\t\t * value of the method that triggered it.\n\t\t\t * @param target {Object} object whose methods should be proxied\n\t\t\t * @param publish {Object} hash of method names to topics each should publish\n\t\t\t */\n\t\t\tfunction proxyPublish(target, publish) {\n\t\t\t\tvar remove;\n\t\t\t\tfor(var method in publish) {\n\t\t\t\t\tif(typeof target[method] == 'function') {\n\t\t\t\t\t\t// Add after advice and save remove function to remove\n\t\t\t\t\t\t// advice when this context is destroyed\n\t\t\t\t\t\tremove = addPublishAdvice(target, method, publish[method]);\n\t\t\t\t\t\tdestroyHandlers.push(remove);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction subscribeTarget(target, subscriptions) {\n\t\t\t\tvar subscribeHandles = [];\n\t\t\t\tfor(var topic in subscriptions) {\n\t\t\t\t\tvar method = subscriptions[topic];\n\t\t\t\t\tif(typeof target[method] == 'function') {\n\t\t\t\t\t\tsubscribeHandles.push(pubsub.subscribe(topic, target, method));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(subscribeHandles.length > 0) {\n\t\t\t\t\tdestroyHandlers.push(function() {\n\t\t\t\t\t\tunsubscribeTarget(subscribeHandles);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction unsubscribeTarget(handles) {\n\t\t\t\tfor (var i = handles.length - 1; i >= 0; --i){\n\t\t\t\t\tpubsub.unsubscribe(handles[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tcontext: {\n\t\t\t\t\tdestroy: function(resolver) {\n\t\t\t\t\t\t// When the context is destroyed, remove all publish and\n\t\t\t\t\t\t// subscribe hooks created in this context\n\t\t\t\t\t\tfor (var i = destroyHandlers.length - 1; i >= 0; --i){\n\t\t\t\t\t\t\tdestroyHandlers[i]();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresolver.resolve();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfacets: {\n\t\t\t\t\tpublish: {\n\t\t\t\t\t\tconnect: function(promise, facet, wire) {\n\t\t\t\t\t\t\tproxyPublish(facet.target, facet.options);\n\t\t\t\t\t\t\tpromise.resolve();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tsubscribe: {\n\t\t\t\t\t\tconnect: function(promise, facet, wire) {\n\t\t\t\t\t\t\tsubscribeTarget(facet.target, facet.options);\n\t\t\t\t\t\t\tpromise.resolve();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n});","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/dojo/store.js":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * wire/dojo/store plugin\n * wire plugin that provides a REST resource reference resolver.  Referencing\n * any REST resource using the format: resource!url/goes/here will create a\n * dojo.store.JsonRest pointing to url/goes/here.  Using the id or query\n * options, you can alternatively resolve references to actual data.\n *\n * wire is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\n\ndefine([], function() {\n\n\tvar pluginInstance;\n\n\t/**\n\t * If wait === true, waits for dataPromise to complete and resolves\n\t * the reference to the resulting concrete data.  If wait !== true,\n\t * resolves the reference to dataPromise.\n\t *\n\t * @param dataPromise\n\t * @param resolver\n\t * @param wait\n\t */\n\tfunction resolveData(dataPromise, resolver, wait) {\n\t\tif(wait === true) {\n\t\t\tdataPromise.then(\n\t\t\t\tfunction(data) {\n\t\t\t\t\tresolver.resolve(data);\n\t\t\t\t},\n\t\t\t\tfunction(err) {\n\t\t\t\t\tresolver.reject(err);\n\t\t\t\t}\n\t\t\t);\n\t\t} else {\n\t\t\tresolver.resolve(dataPromise);\n\t\t}\n\t}\n\n\t/**\n\t * Resolves a dojo.store.JsonRest for the REST resource at the url\n\t * specified in the reference, e.g. resource!url/to/resource\n\t *\n\t * @param resolver\n\t * @param name\n\t * @param refObj\n\t * @param wire\n\t */\n\tfunction resolveResource(resolver, name, refObj, wire) {\n\t\tvar args = { target: name };\n\n\t\tif(refObj.idProperty) args.idProperty = refObj.idProperty;\n\n\t\twire({ create: { module: 'dojo/store/JsonRest', args: args } })\n\t\t\t.then(function(store) {\n\t\t\t\tif(refObj.get) {\n\t\t\t\t\t// If get was specified, get it, and resolve with the resulting item.\n\t\t\t\t\tresolveData(store.get(refObj.get), resolver, refObj.wait);\n\n\t\t\t\t} else if(refObj.query) {\n\t\t\t\t\t// Similarly, query and resolve with the result set.\n\t\t\t\t\tresolveData(store.query(refObj.query), resolver, refObj.wait);\n\n\t\t\t\t} else {\n\t\t\t\t\t// Neither get nor query was specified, so resolve with\n\t\t\t\t\t// the store itself.\n\t\t\t\t\tresolver.resolve(store);\n\t\t\t\t}\n\t\t\t});\n\t}\n\n\t/**\n\t * The plugin instance.  Can be the same for all wiring runs\n\t */\n\tpluginInstance = {\n\t\tresolvers: {\n\t\t\tresource: resolveResource\n\t\t}\n\t};\n\n\treturn {\n\t\twire$plugin: function restPlugin(/* options */) {\n\t\t\treturn pluginInstance;\n\t\t}\n\t};\n});","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/dom/render.js":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * wire/dom/render plugin\n * wire plugin that provides a factory for dom nodes via a simple html\n * template.\n *\n * wire is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\n\ndefine(['./../lib/dom/base', 'when'], function (base, when) {\n\n\tvar parentTypes, parseTemplateRx, getFirstTagNameRx, isPlainTagNameRx,\n\t\tpluginInstance, undef;\n\n\t// elements that could be used as root nodes and their natural parent type\n\tparentTypes = {\n\t\t'li': 'ul',\n\t\t'td': 'tr',\n\t\t'tr': 'tbody',\n\t\t'tbody': 'table',\n\t\t'thead': 'table',\n\t\t'tfoot': 'table',\n\t\t'caption': 'table',\n\t\t'col': 'table',\n\t\t'colgroup': 'table',\n\t\t'option': 'select'\n\t};\n\n\tparseTemplateRx = /\\$\\{([^}]*)\\}/g;\n\tgetFirstTagNameRx = /<\\s*(\\w+)/;\n\tisPlainTagNameRx = /^[A-Za-z]\\w*$/;\n\n\t/**\n\t * Constructs a DOM node and child nodes from a template string.\n\t * Information contained in a hashmap is merged into the template\n\t * via tokens (${name}) before rendering into DOM nodes.\n\t * Nothing is done with the css parameter at this time.\n\t * @param template {String} html template\n\t * @param hashmap {Object} string replacements hash\n\t * @param optRefNode {HTMLElement} node to replace with root node of rendered template\n\t * @returns {HTMLElement}\n\t */\n\tfunction render (template, hashmap, optRefNode /*, optCss */) {\n\t\tvar node;\n\n\t\t// replace tokens (before attempting to find top tag name)\n\t\ttemplate = replaceTokens('' + template, hashmap);\n\n\t\tif (isPlainTagNameRx.test(template)) {\n\t\t\t// just 'div' or 'a' or 'tr', for example\n\t\t\tnode = document.createElement(template);\n\t\t}\n\t\telse {\n\t\t\t// create node from template\n\t\t\tnode = createElementFromTemplate(template);\n\t\t}\n\n\t\tif (optRefNode) {\n\t\t\tnode = safeReplaceElement(node, optRefNode);\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tpluginInstance = {\n\t\tfactories: {\n\t\t\trender: domRenderFactory\n\t\t},\n\t\tproxies: [\n\t\t\tbase.proxyNode\n\t\t]\n\t};\n\n\trender.wire$plugin = function (/* options */) {\n\t\treturn pluginInstance;\n\t};\n\n\t/**\n\t * Finds the first html element in a string, extracts its tag name,\n\t * and looks up the natural parent element tag name for this element.\n\t * @private\n\t * @param template {String}\n\t * @returns {String} the parent tag name, or 'div' if none was found.\n\t */\n\tfunction getParentTagName (template) {\n\t\tvar matches;\n\n\t\t// TODO: throw if no element was ever found?\n\t\tmatches = template.match(getFirstTagNameRx);\n\n\t\treturn parentTypes[matches && matches[1]] || 'div';\n\t}\n\n\t/**\n\t * Creates an element from a text template.  This function does not\n\t * support multiple elements in a template.  Leading and trailing\n\t * text and/or comments are also ignored.\n\t * @private\n\t * @param template {String}\n\t * @returns {HTMLElement} the element created from the template\n\t */\n\tfunction createElementFromTemplate (template) {\n\t\tvar parentTagName, parent, first, tooMany, node;\n\n\t\tparentTagName = getParentTagName(template);\n\t\tparent = document.createElement(parentTagName);\n\t\tparent.innerHTML = template;\n\n\t\t// we just want to return first element (nodelists and fragments\n\t\t// are tricky), so we ensure we only have one.\n\t\t// TODO: try using DocumentFragments to allow multiple root elements\n\n\t\t// try html5-ish API\n\t\tif ('firstElementChild' in parent) {\n\t\t\tfirst = parent.firstElementChild;\n\t\t\ttooMany = first != parent.lastElementChild;\n\t\t}\n\t\telse {\n\t\t\t// loop through nodes looking for elements\n\t\t\tnode = parent.firstChild;\n\t\t\twhile (node && !tooMany) {\n\t\t\t\tif (node.nodeType == 1 /* 1 == element */) {\n\t\t\t\t\tif (!first) first = node;\n\t\t\t\t\telse tooMany = true;\n\t\t\t\t}\n\t\t\t\tnode = node.nextSibling;\n\t\t\t}\n\t\t}\n\n\t\tif (!first) {\n\t\t\tthrow new Error('render: no element found in template.');\n\t\t}\n\t\telse if (tooMany) {\n\t\t\tthrow new Error('render: only one root element per template is supported.');\n\t\t}\n\n\t\treturn first;\n\t}\n\n\t/**\n\t * Creates rendered dom trees for the \"render\" factory.\n\t * @param resolver\n\t * @param componentDef\n\t * @param wire\n\t */\n\tfunction domRenderFactory (resolver, componentDef, wire) {\n\t\twhen(wire(componentDef.options), function (options) {\n\t\t\tvar template;\n\t\t\ttemplate = options.template || options;\n\t\t\treturn render(template, options.replace, options.at, options.css);\n\t\t}).then(resolver.resolve, resolver.reject);\n\t}\n\n\t/**\n\t * Replaces a dom node, while preserving important attributes\n\t * of the original.\n\t * @private\n\t * @param oldNode {HTMLElement}\n\t * @param newNode {HTMLElement}\n\t * @returns {HTMLElement} newNode\n\t */\n\tfunction safeReplaceElement (newNode, oldNode) {\n\t\tvar i, attr, parent;\n\n\t\tfor (i = 0; i < oldNode.attributes.length; i++) {\n\t\t\tattr = oldNode.attributes[i];\n\t\t\tif ('class' == attr.name) {\n\t\t\t\t// merge css classes\n\t\t\t\t// TODO: if we want to be smart about not duplicating classes, implement spliceClassNames from cola/dom/render\n\t\t\t\tnewNode.className = (oldNode.className ? oldNode.className + ' ' : '')\n\t\t\t\t\t+ newNode.className;\n\t\t\t}\n\t\t\t// Note: IE6&7 don't support node.hasAttribute() so we're using node.attributes\n\t\t\telse if (!newNode.attributes[attr.name]) {\n\t\t\t\tnewNode.setAttribute(attr.name, oldNode.getAttribute(attr.name));\n\t\t\t}\n\t\t}\n\t\tparent = oldNode.parentNode;\n\t\tif (parent) {\n\t\t\tparent.replaceChild(newNode, oldNode);\n\t\t}\n\t\treturn newNode;\n\t}\n\n\t/**\n\t * Replaces simple tokens in a string.  Tokens are in the format ${key}.\n\t * Tokens are replaced by values looked up in an associated hashmap.\n\t * If a token's key is not found in the hashmap, an empty string is\n\t * inserted instead.\n\t * @private\n\t * @param template\n\t * @param hashmap {Object} the names of the properties of this object\n\t * are used as keys. The values replace the token in the string.\n\t * @param [missing] {Function} callback that deals with missing properties\n\t * @returns {String}\n\t */\n\tfunction replaceTokens (template, hashmap, missing) {\n\t\tif (!hashmap) {\n\t\t\treturn template;\n\t\t}\n\n\t\tif (!missing) {\n\t\t\tmissing = blankIfMissing;\n\t\t}\n\t\t\n\t\treturn template.replace(parseTemplateRx, function (m, token) {\n\t\t\treturn missing(findProperty(hashmap, token));\n\t\t});\n\t}\n\n\tfunction findProperty (obj, propPath) {\n\t\tvar props, prop;\n\t\tprops = propPath.split('.');\n\t\twhile (obj && (prop = props.shift())) {\n\t\t\tobj = obj[prop];\n\t\t}\n\t\treturn obj;\n\t}\n\n\tfunction blankIfMissing (val) { return val == undef ? '' : val; }\n\n\treturn render;\n\n});\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/jquery/dom.js":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * wire/jquery/dom plugin\n * jQuery-based dom! resolver\n *\n * wire is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\n\ndefine(['../lib/plugin-base/dom', 'jquery'], function(createDomPlugin, jquery) {\n\n\treturn createDomPlugin({\n\t\tquery: function (selector, root) {\n\t\t\treturn jquery(selector, root).toArray();\n\t\t},\n\t\tfirst: function (selector, root) {\n\t\t\treturn jquery(selector, root)[0];\n\t\t},\n\t\taddClass: function(node, cls) {\n\t\t\tjquery(node).addClass(cls);\n\t\t},\n\t\tremoveClass: function(node, cls) {\n\t\t\tjquery(node).removeClass(cls);\n\t\t},\n\t\tplaceAt: function (node, refNode, location) {\n\t\t\tvar $refNode, $children;\n\t\t\t$refNode = jquery(refNode);\n\t\t\t// `if else` is more compressible than switch\n\t\t\tif (!isNaN(location)) {\n\t\t\t\t$children = $(refNode).children();\n\t\t\t\tif (location <= 0) {\n\t\t\t\t\t$refNode.prepend(node);\n\t\t\t\t}\n\t\t\t\telse if (location >= $children.length) {\n\t\t\t\t\t$refNode.append(node);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$children.eq(location).before(node);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (location == 'at') {\n\t\t\t\t$refNode.empty().append(node);\n\t\t\t}\n\t\t\telse if (location == 'last') {\n\t\t\t\t$refNode.append(node);\n\t\t\t}\n\t\t\telse if (location == 'first') {\n\t\t\t\t$refNode.prepend(node);\n\t\t\t}\n\t\t\telse if (location == 'before') {\n\t\t\t\t$refNode.before(node);\n\t\t\t}\n\t\t\telse if (location == 'after') {\n\t\t\t\t$refNode.after(node);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new Error('Unknown dom insertion command: ' + location);\n\t\t\t}\n\t\t\treturn node;\n\t\t}\n\t});\n\n});\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/jquery/on.js":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * wire/dojo/on plugin\n * wire plugin that provides an \"on\" facet that uses dojo/on (dojo 1.7\n * and later) to connect to dom events, and includes support for delegation\n *\n * wire is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\n(function (define) {\ndefine(['../lib/plugin-base/on', 'jquery'], function(createOnPlugin, jquery) {\n\n\t/**\n\t * Listens for dom events at the given node.  If a selector is provided,\n\t * events are filtered to only nodes matching the selector.  Note, however,\n\t * that children of the matching nodes can also fire events that bubble.\n\t * To determine the matching node, use the event object's selectorTarget\n\t * property instead of it's target property.\n\t * @param node {HTMLElement} element at which to listen\n\t * @param event {String} event name ('click', 'mouseenter')\n\t * @param handler {Function} handler function with the following signature: function (e) {}\n\t * @param [selector] {String} optional css query string to use to\n\t */\n\tfunction on (node, event, handler /*, selector */) {\n\t\tvar selector;\n\n\t\tselector = arguments[3];\n\t\thandler = makeEventHandler(handler, selector);\n\n\t\tif (selector) {\n\t\t\tjquery(node).on(event, selector, handler);\n\t\t\treturn function () {\n\t\t\t\tjquery(node).off(event, selector, handler);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tjquery(node).on(event, handler);\n\t\t\treturn function () {\n\t\t\t\tjquery(node).off(event, handler);\n\t\t\t}\n\t\t}\n\t}\n\n\ton.wire$plugin = createOnPlugin({\n\t\ton: on\n\t});\n\n\treturn on;\n\n\tfunction makeEventHandler (handler, selector) {\n\t\treturn function (e, o) {\n\t\t\tif (selector) e.selectorTarget = this;\n\t\t\thandler(e, o);\n\t\t}\n\t}\n\n});\n}(\n\ttypeof define == 'function' && define.amd\n\t\t? define\n\t\t: function (deps, factory) { module.exports = factory.apply(this, deps.map(require)); }\n));\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/jquery/ui.js":"/** @license MIT License (c) copyright 2011-2013 original author or authors */\n\n/**\n * Allows declarative creation of jQuery UI widgets.\n * wire is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * @author Brian Cavalier\n * @author John Hann\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\ndefine(['when', 'jquery', '../lib/WireProxy'], function (when, $, WireProxy) {\n\n\tvar typeDataProp, proxyMixin, pluginInstance;\n\n\ttypeDataProp = 'wire$type';\n\n\tproxyMixin = getWidgetProxyMixin();\n\n\tpluginInstance = {\n\t\tfactories: {\n\t\t\twidget: widgetFactory\n\t\t},\n\t\tproxies: [\n\t\t\tproxyWidget\n\t\t]\n\t};\n\n\treturn {\n\t\twire$plugin: function jQueryUIPlugin (/* options */) {\n\t\t\treturn pluginInstance;\n\t\t}\n\t};\n\n\t/**\n\t * Creates a jQuery UI widget on top of a dom node.\n\t * Since jQuery UI widgets don't really have a normal API, the proxy has to\n\t * hunt around for \"properties\" and/or \"methods\" in the proxy.\n\t * jQuery UI widgets don't actually have properties, but they do have options\n\t * and data attributes.  The proxy will get/set these instead.\n\t * In order to allow widgets to be bound to eachother via property changes,\n\t * the proxy adds a feature to parse methods that look like \"getXXX\" or\n\t * \"setXXX\" into property getters and setters.  These getters and setters can\n\t * be used in a function pipeline, for instance.\n\t * @param {Deferred} resolver\n\t * @param {Object} spec\n\t * @param {Function} wire\n\t */\n\tfunction widgetFactory (resolver, spec, wire) {\n\t\tvar type, widget;\n\n\t\ttype = spec.options.type;\n\n\t\tif (!type) throw new Error('widget factory requires a \"type\" property.');\n\n\t\t// jQuery UI widgets place things at $[type] $.ui[type] and $.fn[type].\n\t\t// however, wijmo widgets only appear at $.fn[type].\n\t\tif (typeof $.fn[type] != 'function') {\n\t\t\tthrow new Error('widget factory could not find a jQuery UI Widget constructor for ' + type);\n\t\t}\n\n\t\twidget = when.join(wire(spec.options.node), wire(spec.options.options || {}))\n\t\t\t.spread(createWidget);\n\n\t\tresolver.resolve(widget);\n\n\t\tfunction createWidget (el, options) {\n\t\t\tvar $w;\n\n\t\t\tif (!isNode(el) && !isjQWrapped(el)) throw new Error('widget factory could not resolve \"node\" property: ' + spec.options.node);\n\n\t\t\t$w = $(el);\n\t\t\t$w.data(typeDataProp, type);\n\n\t\t\treturn $w[type](options);\n\t\t}\n\n\t}\n\n\t/**\n\t * Extends the base wire proxy if the target is a jQuery UI widget.\n\t * @param {Object} proxy\n\t * @return {Object} proxy\n\t */\n\tfunction proxyWidget (proxy) {\n\t\tif (isWidget(proxy.target)) {\n\t\t\treturn WireProxy.extend(proxy, proxyMixin);\n\t\t}\n\t}\n\n\t/**\n\t * Creates an object to use to extend the base wire proxy.\n\t * @private\n\t * @return {Object} an object ot mix into the base proxy.\n\t */\n\tfunction getWidgetProxyMixin () {\n\t\treturn {\n\t\t\tget: function (name) {\n\t\t\t\tvar $w, type, data;\n\n\t\t\t\t$w = this.target;\n\t\t\t\ttype = $w.data(typeDataProp);\n\n\t\t\t\t// if there is a method with this name, call it to get value\n\t\t\t\tif (typeof $w[name] == 'function') return $w[name]();\n\n\t\t\t\t// if there is an option (not undefined), then return that\n\t\t\t\tif (hasOption($w, type, name)) return $w[type]('option', name);\n\n\t\t\t\t// check if it's a data item\n\t\t\t\tdata = $w.data();\n\t\t\t\tif (name in data) {\n\t\t\t\t\treturn data[name];\n\t\t\t\t}\n\n\t\t\t\t// try an auto-getter/setter property\n\t\t\t\treturn createAccessor(this, $w, name);\n\t\t\t},\n\n\t\t\tset: function (name, value) {\n\t\t\t\tvar $w, type;\n\n\t\t\t\t$w = this.target;\n\t\t\t\ttype = $w.data(typeDataProp);\n\n\t\t\t\t// if there is a function with this name, call it to set value\n\t\t\t\tif (typeof $w[name] == 'function') return $w[name](value);\n\n\t\t\t\t// if there is an option (not undefined), set it\n\t\t\t\tif (hasOption($w, type, name)) return $w[type]('option', name, value);\n\n\t\t\t\t// must be a data item\n\t\t\t\treturn $w.data(name, value);\n\n\t\t\t},\n\n\t\t\tinvoke: function (method, args) {\n\t\t\t\tvar $w, type, func, margs;\n\n\t\t\t\t$w = this.target;\n\t\t\t\ttype = $w.data(typeDataProp);\n\t\t\t\tfunc = typeof method == 'function'\n\t\t\t\t\t? method // wrapped function\n\t\t\t\t\t: this.get(method); // wire property\n\n\t\t\t\tif (typeof func == 'function') {\n\t\t\t\t\treturn func.apply(null, args);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmargs = [method];\n\t\t\t\t\tif (args && args.length) {\n\t\t\t\t\t\t// using margs's slice to ensure args is an array (instead of Arguments)\n\t\t\t\t\t\tmargs = margs.concat(margs.slice.apply(args));\n\t\t\t\t\t}\n\n\t\t\t\t\treturn $w[type].apply($w, margs);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tdestroy: function () {\n\t\t\t\tvar $w = this.target;\n\t\t\t\t$w.destroy();\n\t\t\t},\n\n\t\t\tclone: function (options) {\n\t\t\t\tvar $w = this.target;\n\t\t\t\t// default is to clone deep (when would anybody not want deep?)\n\t\t\t\treturn $w.clone(!('deep' in options) || options.deep);\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction hasOption ($w, type, name) {\n\t\t// thankfully, all options should be pre-defined in a jquery ui widget\n\t\tvar options = $w[type]('option');\n\t\treturn options && name in options;\n\t}\n\n\t/**\n\t * Creates a getter or setter, if there is a matching \"property\".\n\t * @private\n\t * @param {Object} proxy\n\t * @param {Object} $w jQuery-wrapped node of the widget.\n\t * @param {String} name of the \"property\"\n\t */\n\tfunction createAccessor (proxy, $w, name) {\n\t\tvar type, prop;\n\n\t\ttype = name.substr(0, 3);\n\t\tprop = name.charAt(3).toLowerCase() + name.substr(4);\n\n\t\tif (type == 'get') {\n\t\t\treturn function () {\n\t\t\t\treturn proxy.get(prop);\n\t\t\t};\n\t\t}\n\t\telse if (type == 'set') {\n\t\t\treturn function (value) {\n\t\t\t\treturn proxy.set(prop, value);\n\t\t\t};\n\t\t}\n\t}\n\n\tfunction isWidget (it) {\n\t\treturn it\n\t\t\t&& it.data\n\t\t\t&& !!it.data(typeDataProp);\n\t}\n\n\tfunction isNode (it) {\n\t\treturn typeof Node == 'object'\n\t\t\t? it instanceof Node\n\t\t\t: it && typeof it == 'object' && typeof it.nodeType == 'number' && typeof it.nodeName == 'string';\n\t}\n\n\tfunction isjQWrapped (it) {\n\t\treturn typeof it == 'function' && typeof it.jquery == 'function';\n\t}\n\n});\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/dom/transform/cardinality.js":"(function (define) {\ndefine(function (require) {\n\t\"use strict\";\n\n\tvar mapClasses, defaultClasses, defaultOtherwise;\n\n\tmapClasses = require('./mapClasses');\n\n\tdefaultClasses = {\n\t\t0: 'zero',\n\t\t1: 'one'\n\t};\n\n\tdefaultOtherwise = 'many';\n\n\t/**\n\t * Creates a dom class mapper (see mapClasses) that maps numbers to\n\t * a cardinality class, such as 0 -> 'zero', 1 -> 'one', 2 -> 'many'.\n\t * An optional prefix may be supplied to allow specialized class names,\n\t * such as 0 -> 'items-in-cart-zero', 1 -> 'items-in-cart-one', 2 -> 'items-in-cart-many'\n\t *\n\t * @param options {Object|String} if a String, it is used directly as the prefix.\n\t * @param [options.prefix] {String} Prefix to prepend to cardinality classes, a '-'\n\t * will be appended to this when forming the cardinality class.\n\t * @param [options.otherwise] {String} suffix to use when the input number\n\t * is not 0 or 1, defaults to \"many\".  This should *not* already contain the prefix.\n\t *\n\t * @return {Function} function that will map a number to a css class name.\n\t */\n\treturn function(options) {\n\n\t\tvar classMap, prefix, key;\n\n\t\tclassMap = {};\n\t\tprefix = '';\n\n\t\tif(!options) options = {};\n\n\t\tif(typeof options == 'string') {\n\t\t\tprefix = options + '-';\n\t\t\toptions = {};\n\t\t} else if(options.prefix) {\n\t\t\tprefix = options.prefix + '-';\n\t\t}\n\n\t\tfor(key in defaultClasses) {\n\t\t\tclassMap[key] = prefix + defaultClasses[key];\n\t\t}\n\n\t\toptions.otherwise = prefix + defaultOtherwise;\n\t\toptions.map = classMap;\n\n\t\treturn mapClasses(options);\n\t}\n\n});\n}(\n\ttypeof define == 'function' && define.amd\n\t\t? define\n\t\t: function (factory) { module.exports = factory(require); }\n));","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/dom/transform/mapClasses.js":"(function (define) {\ndefine(function (require) {\n\"use strict\";\n\n\tvar mapTokenList, replaceClasses;\n\n\tmapTokenList = require('./mapTokenList');\n\treplaceClasses = require('./replaceClasses');\n\n\treturn function (options) {\n\t\tvar mapper, replacer;\n\n\t\tif(!options) options = {};\n\n\t\tif (!options.group) options.group = mapToGroup(options.map);\n\n\t\tmapper = options.mapper || mapTokenList(options.map, options);\n\t\treplacer = options.replacer || replaceClasses(options);\n\n\t\treturn options.node\n\t\t\t? function (val) { return replacer(mapper(val)); }\n\t\t\t: function (node, val) { return replacer(node, mapper(val)); };\n\t};\n\n\tfunction mapToGroup (map) {\n\t\treturn Object.keys(map).reduce(function (group, p) {\n\t\t\tvar str = '' + map[p];\n\t\t\tif (str) group.push(str);\n\t\t\treturn group;\n\t\t}, []);\n\t}\n\n});\n}(\n\ttypeof define == 'function' && define.amd\n\t\t? define\n\t\t: function (factory) { module.exports = factory(require); }\n));","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/dom/transform/mapTokenList.js":"(function (define) {\ndefine(function () {\n\"use strict\";\n\n\tvar parser = /(^|\\s+)([\\S]+)/g;\n\n\t/**\n\t * Creates a function that will replace tokens using the supplied\n\t * token map.\n\t * @param map {Object} map of token -> replacement\n\t * @param [options.otherwise] {String} replacement to use for tokens\n\t * not found in map\n\t * @return {Function}\n\t */\n\treturn function (map, options) {\n\t\tvar fallbackToken;\n\n\t\tif (!options) options = {};\n\n\t\tfallbackToken = options.otherwise || '';\n\n\t\t/**\n\t\t * Replaces tokens in tokenList using the configured map and options\n\t\t * @param tokenList {String|*} String of space-separated tokens, or anything\n\t\t * coercable thereto.\n\t\t * @return {String} tokenList with tokens replaced\n\t\t */\n\t\treturn function translateTokenLists (tokenList) {\n\t\t\ttokenList = '' + tokenList;\n\t\t\treturn tokenList.replace(parser, function (m, s, token) {\n\t\t\t\t// if there's a delimiter already (spaces, typically),\n\t\t\t\t// replace it. if a translated value exists, use it.\n\t\t\t\t// otherwise, use original token.\n\t\t\t\tvar s2 = s + (token in map ? map[token] : fallbackToken);\n\t\t\t\treturn s2 == s ? '' : s2;\n\t\t\t});\n\t\t}\n\n\t};\n\n});\n}(\n\ttypeof define == 'function' && define.amd\n\t\t? define\n\t\t: function (factory) { module.exports = factory(); }\n));","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/dom/transform/replaceClasses.js":"(function (define) {\ndefine(function (require) {\n\"use strict\";\n\n\tvar removeRxParts, trimLeadingRx, splitClassNamesRx, partial;\n\n\tremoveRxParts = ['(\\\\s+|^)(', ')(\\\\b(?![\\\\-_])|$)'];\n\ttrimLeadingRx = /^\\s+/;\n\tsplitClassNamesRx = /(\\b\\s+\\b)|(\\s+)/g;\n\tpartial = require('../../lib/functional').partial;\n\n\t/**\n\t * Configures a transform function that satisfies the most common\n\t * requirement for oocss states: while adding new classes, it removes\n\t * classes in the same group of states. This allows the dev to add\n\t * and remove classes in the same atomic action.\n\t * @param [options.node] {HTMLElement}\n\t * @param [options] {Object} a hashmap of options\n\t * @param [options.group] {Array|String} If specified, this is a\n\t *   list of all possible classes in the group.  If a single string is\n\t *   provided, it should be a space-delimited (TokenList) of classes.\n\t * @param [options.initial] {Array|String} If specified, this is the\n\t *   initial set of classes to set on the element.  This isn't just a\n\t *   convenience feature: it may be necessary for this transform to work\n\t *   correctly if not specifying a group.  See the description.\n\t * @param [options.remover] {Function} a custom remover function that can\n\t *   be used to remove old classes when adding new ones.  If this option is\n\t *   specified, the group option is ignored. Remover signature:\n\t *   function (classesToRemove, baseRemover) { return newClasses; }\n\t *   The baseRemover param is a function that will remove classes in the\n\t *   usual way.  Call baseRemover.setRemoves(groupOrString) to set\n\t *   the classes that should be removed when next invoked.\n\t *\n\t * @description\n\t * If the group param is provided, all of the class names in the group\n\t * will be removed from the element when new classes are added. A group\n\t * is a set of classes that always change together (e.g. \"can-edit\n\t * can-delete can-view can-add\" or \"form-enabled form-disabled\"). A\n\t * group could consist of several groups at once as long as the classes\n\t * for those groups are always set together, as well.\n\t * If the group param is omitted, group behavior can still be achieved\n\t * under most circumstances. As long as the transform function is always\n\t * used on the same group (or set of groups)*, an algorithm that removes\n\t * the previously set classes also works fine. (*It is possible to\n\t * set classes that are not specified within the configured group.)\n\t *\n\t * @example 1: groups is a string\n\t *   oocssSetter = configureReplaceClassNames(viewNode, {\n\t *     group: 'edit-mode readonly-mode'\n\t *   });\n\t *   // later:\n\t *   oocssSetter('edit-mode'); // viewNode.className == 'edit-mode';\n\t *   // even later:\n\t *   oocssSetter('readonly-mode'); // viewNode.className == 'readonly-mode';\n\t *\n\t * @example 2: groups is an array\n\t *   oocssSetter = configureReplaceClassNames(viewNode, {\n\t *     group: ['edit-mode', 'readonly-mode']\n\t *   });\n\t *\n\t * @example 3: multiple groups at once\n\t *   oocssSetter = configureReplaceClassNames(viewNode, {\n\t *     group: ['edit-mode readonly-mode form-enabled form-disabled']\n\t *   });\n\t *   // later, be sure to set both groups at once:\n\t *   oocssSetter('edit-mode form-enabled');\n\t *\n\t * @example 4: no group specified\n\t *   oocssSetter = configureReplaceClassNames(viewNode, {\n\t *     initial: 'form-disabled'\n\t *   });\n\t *   // later:\n\t *   oocssSetter('form-enabled'); // form-disabled is removed\n\t *\n\t * @example 5: extra classes not in a group\n\t *   oocssSetter = configureReplaceClassNames(viewNode, {\n\t *     group: ['edit-mode readonly-mode']\n\t *   });\n\t *   // later (this is problematic if you didn't specify a group!)\n\t *   oocssSetter('edit-mode error-in-form');\n\t */\n\treturn function configureReplaceClasses (options) {\n\t\tvar group, remover, replace, prev = '';\n\n\t\tif (!options) options = {};\n\n\t\tgroup = options.group;\n\n\t\tif (options.remover) {\n\t\t\tremover = createCustomRemover(options.remover);\n\t\t}\n\t\telse if (group) {\n\t\t\tremover = createClassRemover(group);\n\t\t}\n\t\telse {\n\t\t\tremover = (function createPrevRemover (remover) {\n\t\t\t\treturn function removePrev (classes) {\n\t\t\t\t\tremover.setRemoves(prev);\n\t\t\t\t\treturn remover(classes);\n\t\t\t\t};\n\t\t\t}(createClassRemover()));\n\t\t}\n\n\t\treplace = options.node\n\t\t\t? partial(replaceClasses, options.node)\n\t\t\t: replaceClasses;\n\n\t\tif (options.initial) {\n\t\t\t// set the original classes\n\t\t\treplace(options.initial);\n\t\t}\n\n\t\treturn replace;\n\n\t\tfunction replaceClasses (node, classes) {\n\t\t\tvar leftovers;\n\n\t\t\tif (!classes) classes = '';\n\n\t\t\t// there were likely classes we didn't remove\n\t\t\tleftovers = remover(node.className);\n\n\t\t\t// save\n\t\t\tprev = classes;\n\n\t\t\t// assemble new classes\n\t\t\tclasses = classes + (classes && leftovers ? ' ' : '') + leftovers;\n\n\t\t\treturn node.className = classes;\n\t\t}\n\n\t\tfunction createClassRemover (tokens) {\n\t\t\tvar removeRx;\n\t\t\tfunction genRx (tokens) {\n\t\t\t\tif(!tokens) return;\n\t\t\t\t// convert from array\n\t\t\t\ttokens = typeof tokens.join == 'function'\n\t\t\t\t\t? tokens.join('|')\n\t\t\t\t\t: tokens.replace(splitClassNamesRx, '|');\n\t\t\t\t// set up the regexp to remove everything in the set of tokens\n\t\t\t\tremoveRx = new RegExp(removeRxParts.join(tokens), 'g');\n\t\t\t}\n\t\t\tfunction remover (classes) {\n\t\t\t\treturn classes.replace(removeRx, '').replace(trimLeadingRx, '');\n\t\t\t}\n\t\t\tremover.setRemoves = genRx;\n\t\t\tif (tokens) genRx(tokens);\n\t\t\treturn remover;\n\t\t}\n\n\t\tfunction createCustomRemover (custom) {\n\t\t\tvar remover = createClassRemover();\n\t\t\treturn function removeCustom (classes) {\n\t\t\t\treturn custom(classes, remover);\n\t\t\t};\n\t\t}\n\n\t};\n\n});\n}(\n\ttypeof define == 'function' && define.amd\n\t\t? define\n\t\t: function (factory) { module.exports = factory(require); }\n));\n","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/dom/transform/toggleClasses.js":"(function (define) {\ndefine(function (require) {\n\n\tvar createReplaceClasses, partial;\n\n\tcreateReplaceClasses = require('./replaceClasses');\n\tpartial = require('../../lib/functional').partial;\n\n\treturn function (options) {\n\t\tvar args, toggle, removes, replaceClasses,\n\t\t\ttoggleClasses, addClasses, removeClasses;\n\n\t\treplaceClasses = createReplaceClasses({ remover: classRemover });\n\t\tremoves = '';\n\n\t\targs = [];\n\n\t\tif(!options) options = {};\n\n\t\tif (options.node) args.push(options.node);\n\t\tif (options.classes) args.push(options.classes);\n\n\t\ttoggleClasses = fixArgsAndCall.bind(null, doToggleClasses);\n\t\taddClasses = fixArgsAndCall.bind(null, doAddClasses);\n\t\tremoveClasses = fixArgsAndCall.bind(null, doRemoveClasses);\n\n\t\ttoggle = makePartial([toggleClasses].concat(args));\n\t\ttoggle.add = makePartial([addClasses].concat(args));\n\t\ttoggle.remove = makePartial([removeClasses].concat(args));\n\n\t\treturn toggle;\n\n\n\t\tfunction fixArgsAndCall(func, node, classes) {\n\t\t\t// Since we're allowing either the node, or the classes, or both(!)\n\t\t\t// to be pre-bound, have to check the arguments here and swap\n\t\t\t// if necessary.\n\t\t\tif(typeof node == 'string') {\n\t\t\t\tremoves = node;\n\t\t\t\tnode = classes;\n\t\t\t\tclasses = removes;\n\t\t\t} else {\n\t\t\t\tremoves = classes;\n\t\t\t}\n\n\t\t\treturn func(node, classes);\n\t\t}\n\n\t\tfunction doToggleClasses(node, classes) {\n\t\t\t// toggle is basically (a ^ b) where a == node's classes and b == toggled classes\n\t\t\tvar fake, adds;\n\t\t\t// get everything that shouldn't be removed (adds)\n\t\t\tfake = { className: classes };\n\t\t\tremoveClasses(fake, node.className);\n\t\t\tadds = fake.className;\n\t\t\t// remove toggled classes and put back adds\n\t\t\tremoves = classes;\n\t\t\treplaceClasses(node, adds);\n\t\t\treturn node;\n\t\t}\n\n\t\tfunction doRemoveClasses(node) {\n\t\t\treplaceClasses(node, '');\n\t\t\treturn node;\n\t\t}\n\n\t\tfunction doAddClasses(node, classes) {\n\t\t\treplaceClasses(node, classes);\n\t\t\treturn node;\n\t\t}\n\n\t\tfunction classRemover (classes, remover) {\n\t\t\tremover.setRemoves(removes);\n\t\t\treturn remover(classes);\n\t\t}\n\n\t};\n\n\tfunction makePartial(args) {\n\t\treturn partial.apply(null, args);\n\t}\n\n});\n}(\n\ttypeof define == 'function' && define.amd\n\t\t? define\n\t\t: function (factory) { module.exports = factory(require); }\n));","/home/travis/build/npmtest/node-npmtest-wire/node_modules/wire/lib/plugin-base/dom.js":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * dom plugin helper\n *\n * wire is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\ndefine(['wire/domReady', 'when', '../dom/base', '../object'], function(domReady, when, base, object) {\n\n\tfunction getElementFactory (resolver, componentDef, wire) {\n\t\twhen(wire(componentDef.options), function (element) {\n\n\t\t\tif (!element || !element.nodeType || !element.tagName) {\n\t\t\t\tthrow new Error('dom: non-element reference provided to element factory');\n\t\t\t}\n\n\t\t\treturn element;\n\t\t}).then(resolver.resolve, resolver.reject);\n\t}\n\n\treturn function createDomPlugin(options) {\n\n\t\tvar getById, query, first, addClass, removeClass, placeAt,\n\t\t\tdoById, doPlaceAt, resolveQuery;\n\n\t\tgetById = options.byId || base.byId;\n\t\tquery = options.query || base.querySelectorAll;\n\t\tfirst = options.first || base.querySelector;\n\t\taddClass = options.addClass;\n\t\tplaceAt = options.placeAt || base.placeAt;\n\t\tremoveClass = options.removeClass;\n\n\t\tfunction doByIdImpl(resolver, name) {\n\t\t\tvar node;\n\n\t\t\t// if dev omitted name, they're looking for the resolver itself\n\t\t\tif (!name) {\n\t\t\t\treturn resolver.resolve(getById);\n\t\t\t}\n\n\t\t\tnode = getById(name);\n\t\t\tif (node) {\n\t\t\t\tresolver.resolve(node);\n\t\t\t} else {\n\t\t\t\tresolver.reject(new Error('No DOM node with id: ' + name));\n\t\t\t}\n\t\t}\n\n\t\tdoById = function(resolver, name /*, refObj, wire*/) {\n\t\t\tdomReady(function() {\n\t\t\t\tdoById = doByIdImpl;\n\t\t\t\tdoByIdImpl(resolver, name);\n\t\t\t});\n\t\t};\n\n\t\tfunction doQuery(name, refObj, root, queryFunc) {\n\t\t\tvar result, i;\n\n\t\t\tresult = queryFunc(name, root);\n\n\t\t\t// if dev supplied i, try to use it\n\t\t\tif (typeof refObj.i != 'undefined') {\n\t\t\t\ti = refObj.i;\n\t\t\t\tif (result[i]) { // do not use `i in result` since IE gives a false positive\n\t\t\t\t\treturn result[i];\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error('Query \"' + name + '\" did not find an item at position ' + i);\n\t\t\t\t}\n\t\t\t} else if (queryFunc == first && !result) {\n\t\t\t\tthrow new Error('Query \"' + name + '\" did not find anything');\n\t\t\t} else {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tfunction doPlaceAtImpl(resolver, facet, wire) {\n\t\t\tvar futureRefNode, node, options, operation;\n\n\t\t\toptions = facet.options;\n\t\t\tnode = facet.target;\n\n\t\t\t// get first property and use it as the operation\n\t\t\tfor (var p in options) {\n\t\t\t\tif (object.hasOwn(options, p)) {\n\t\t\t\t\toperation = p;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfutureRefNode = wire(makeQueryRef(options[operation]));\n\n\t\t\twhen(futureRefNode, function (refNode) {\n\t\t\t\treturn placeAt(node, refNode, operation);\n\t\t\t}).then(resolver.resolve, resolver.reject);\n\t\t}\n\n\t\tdoPlaceAt = function(resolver, facet, wire) {\n\t\t\tdomReady(function() {\n\t\t\t\tdoPlaceAt = doPlaceAtImpl;\n\t\t\t\tdoPlaceAtImpl(resolver, facet, wire);\n\t\t\t});\n\t\t};\n\n\t\tfunction resolveQueryImpl(resolver, name, refObj, wire, queryFunc) {\n\t\t\tvar futureRoot;\n\n\t\t\tif (!queryFunc) {\n\t\t\t\tqueryFunc = query;\n\t\t\t}\n\n\t\t\t// if dev omitted name, they're looking for the resolver itself\n\t\t\tif (!name) {\n\t\t\t\treturn resolver.resolve(queryFunc);\n\t\t\t}\n\n\t\t\t// get string ref or object ref\n\t\t\tif (refObj.at && !refObj.isRoot) {\n\t\t\t\tfutureRoot = wire(makeQueryRoot(refObj.at));\n\t\t\t}\n\n\t\t\t// sizzle will default to document if refObj.at is unspecified\n\t\t\twhen(futureRoot, function (root) {\n\t\t\t\treturn doQuery(name, refObj, root, queryFunc);\n\t\t\t}).then(resolver.resolve, resolver.reject);\n\t\t}\n\n\t\t/**\n\t\t *\n\t\t * @param resolver {Resolver} resolver to notify when the ref has been resolved\n\t\t * @param name {String} the dom query\n\t\t * @param refObj {Object} the full reference object, including options\n\t\t * @param wire {Function} wire()\n\t\t * @param [queryFunc] {Function} the function to use to query the dom\n\t\t */\n\t\tresolveQuery = function(resolver, name, refObj, wire, queryFunc) {\n\n\t\t\tdomReady(function() {\n\t\t\t\tresolveQuery = resolveQueryImpl;\n\t\t\t\tresolveQueryImpl(resolver, name, refObj, wire, queryFunc);\n\t\t\t});\n\n\t\t};\n\n\t\t/**\n\t\t * dom.first! resolver.\n\t\t *\n\t\t * @param resolver {Resolver} resolver to notify when the ref has been resolved\n\t\t * @param name {String} the dom query\n\t\t * @param refObj {Object} the full reference object, including options\n\t\t * @param wire {Function} wire()\n\t\t */\n\t\tfunction resolveFirst(resolver, name, refObj, wire) {\n\t\t\tresolveQuery(resolver, name, refObj, wire, first);\n\t\t}\n\n\t\tfunction makeQueryRoot(ref) {\n\n\t\t\tvar root = makeQueryRef(ref);\n\n\t\t\tif(root) {\n\t\t\t\troot.isRoot = true;\n\t\t\t}\n\n\t\t\treturn root;\n\t\t}\n\n\t\tfunction makeQueryRef(ref) {\n\t\t\treturn typeof ref == 'string' ? { $ref: ref } : ref;\n\t\t}\n\n\t\tfunction createResolver(resolverFunc, options) {\n\t\t\treturn function(resolver, name, refObj, wire) {\n\t\t\t\tif(!refObj.at) {\n\t\t\t\t\trefObj.at = options.at;\n\t\t\t\t} else {\n\t\t\t\t\trefObj.at = makeQueryRoot(refObj.at);\n\t\t\t\t}\n\n\t\t\t\treturn resolverFunc(resolver, name, refObj, wire);\n\t\t\t};\n\t\t}\n\n\t\tfunction handleClasses(node, add, remove) {\n\t\t\tif(add) {\n\t\t\t\taddClass(node, add);\n\t\t\t}\n\n\t\t\tif(remove) {\n\t\t\t\tremoveClass(node, remove);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * DOM plugin factory\n\t\t */\n\t\treturn function(options) {\n\t\t\tvar classes, resolvers, facets, factories, context, htmlElement;\n\n\t\t\toptions.at = makeQueryRoot(options.at);\n\t\t\tclasses = options.classes;\n\t\t\tcontext = {};\n\n\t\t\tif(classes) {\n\t\t\t\tdomReady(function() {\n\t\t\t\t\thtmlElement = document.getElementsByTagName('html')[0];\n\t\t\t\t});\n\n\t\t\t\tcontext.initialize = function (resolver) {\n\t\t\t\t\tdomReady(function () {\n\t\t\t\t\t\thandleClasses(htmlElement, classes.init);\n\t\t\t\t\t\tresolver.resolve();\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t\tcontext.ready = function (resolver) {\n\t\t\t\t\tdomReady(function () {\n\t\t\t\t\t\thandleClasses(htmlElement, classes.ready, classes.init);\n\t\t\t\t\t\tresolver.resolve();\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t\tif(classes.ready) {\n\t\t\t\t\tcontext.destroy = function (resolver) {\n\t\t\t\t\t\tdomReady(function () {\n\t\t\t\t\t\t\thandleClasses(htmlElement, null, classes.ready);\n\t\t\t\t\t\t\tresolver.resolve();\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfactories = {\n\t\t\t\telement: getElementFactory\n\t\t\t};\n\n\t\t\tfacets = {\n\t\t\t\tinsert: {\n\t\t\t\t\tinitialize: doPlaceAt\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tresolvers = {};\n\t\t\t// id and dom are synonyms\n\t\t\t// dom is deprecated and for backward compat only\n\t\t\tresolvers.id = resolvers.dom = doById;\n\n\t\t\tif (query) {\n\t\t\t\t// dom.first is deprecated\n\t\t\t\tresolvers.first = createResolver(resolveFirst, options);\n\t\t\t\tresolvers['dom.first'] = function() {\n\t\t\t\t\t// TODO: Deprecation warning\n\t\t\t\t\tresolvers.first.apply(resolvers, arguments);\n\t\t\t\t};\n\n\t\t\t\t// all and query are synonyms\n\t\t\t\tresolvers.all = resolvers.query = createResolver(resolveQuery, options);\n\t\t\t\tresolvers['dom.all'] = resolvers['dom.query'] = function() {\n\t\t\t\t\t// TODO: Deprecation warning\n\t\t\t\t\tresolvers.query.apply(resolvers, arguments);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tcontext: context,\n\t\t\t\tresolvers: resolvers,\n\t\t\t\tfacets: facets,\n\t\t\t\tfactories: factories,\n\t\t\t\tproxies: [\n\t\t\t\t\tbase.proxyNode\n\t\t\t\t]\n\t\t\t};\n\n\t\t};\n\t};\n});\n"}